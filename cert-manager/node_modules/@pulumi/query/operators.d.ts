import { AsyncIterable, AsyncIterableIterator, AsyncQuerySource, Evaluator, GroupedAsyncIterableIterator, Operator, OrderKey } from "./interfaces";
export declare function filter<TSource>(f: (t: TSource, i: number) => boolean | Promise<boolean>): Operator<TSource, TSource>;
export declare function flatMap<TSource, TInner, TResult = TInner>(selector: (t: TSource, index: number) => AsyncQuerySource<TInner>, resultSelector?: (t: TSource, ti: TInner) => TResult | Promise<TResult>): Operator<TSource, TResult>;
export declare function map<TSource, TResult>(f: (t: TSource, i: number) => TResult | Promise<TResult>): Operator<TSource, TResult>;
export declare function skip<TSource>(n: number): Operator<TSource, TSource>;
export declare function skipWhile<TSource>(predicate: (t: TSource, i: number) => boolean | Promise<boolean>): Operator<TSource, TSource>;
export declare function take<TSource>(n: number): Operator<TSource, TSource>;
export declare function takeWhile<TSource>(predicate: (t: TSource, i: number) => boolean | Promise<boolean>): Operator<TSource, TSource>;
export declare function join<TOuter, TInner, TKey, TResult>(inner: AsyncIterableIterator<TInner>, outerKeySelector: (to: TOuter) => TKey | Promise<TKey>, innerKeySelector: (ti: TInner) => TKey | Promise<TKey>, resultSelector: (to: TOuter, ti: TInner) => TResult | Promise<TResult>): Operator<TOuter, TResult>;
export declare function groupJoin<TOuter, TInner, TKey, TResult>(inner: AsyncIterableIterator<TInner>, outerKeySelector: (to: TOuter) => TKey | Promise<TKey>, innerKeySelector: (ti: TInner) => TKey | Promise<TKey>, resultSelector: (to: TOuter, ti: AsyncQuerySource<TInner>) => TResult | Promise<TResult>): Operator<TOuter, TResult>;
export declare function concat<TSource>(iter: AsyncIterable<TSource>): Operator<TSource, TSource>;
export declare function orderBy<TSource>(keySelector: (t: TSource) => OrderKey | Promise<OrderKey>): Operator<TSource, TSource>;
export declare function orderByDescending<TSource>(keySelector: (t: TSource) => OrderKey | Promise<OrderKey>): Operator<TSource, TSource>;
export declare function reverse<TSource>(): Operator<TSource, TSource>;
export declare function groupBy<TSource, TKey, TResult = TSource>(keySelector: (t: TSource) => TKey | Promise<TKey>, elementSelector?: (t: TSource) => TResult | Promise<TResult>): (source: AsyncIterableIterator<TSource>) => AsyncIterableIterator<GroupedAsyncIterableIterator<TKey, TResult>>;
export declare function distinct<TSource>(): Operator<TSource, TSource>;
export declare function union<TSource>(second: AsyncIterableIterator<TSource>): Operator<TSource, TSource>;
export declare function intersect<TSource>(second: AsyncIterableIterator<TSource>): Operator<TSource, TSource>;
export declare function except<TSource>(second: AsyncIterableIterator<TSource>): Operator<TSource, TSource>;
export declare function toArray<TSource>(): Evaluator<TSource, TSource[]>;
export declare function toMap<TKey, TSource, TResult = TSource>(keySelector: (t: TSource) => TKey | Promise<TKey>, elementSelector?: (t: TSource) => TResult | Promise<TResult>): Evaluator<TSource, Map<TKey, TResult>>;
export declare function ofType<TSource, TResult extends TSource>(typeGuard: (o: TSource) => o is TResult): Operator<TSource, TResult>;
export declare function first<TSource>(predicate?: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, TSource>;
export declare function firstOrDefault<TSource>(defaultValue: TSource, predicate?: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, TSource>;
export declare function last<TSource>(predicate?: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, TSource>;
export declare function lastOrDefault<TSource>(defaultValue: TSource, predicate?: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, TSource>;
export declare function single<TSource>(predicate?: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, TSource>;
export declare function singleOrDefault<TSource>(defaultValue: TSource, predicate?: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, TSource>;
export declare function elementAt<TSource>(index: number): Evaluator<TSource, TSource>;
export declare function elementAtOrDefault<TSource>(defaultValue: TSource, index: number): Evaluator<TSource, TSource>;
export declare function defaultIfEmpty<TSource>(defaultValue: TSource): Operator<TSource, TSource>;
export declare function any<TSource>(predicate?: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, boolean>;
export declare function all<TSource>(predicate: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, boolean>;
export declare function contains<TSource>(value: TSource): Evaluator<TSource, boolean>;
export declare function count<TSource>(predicate?: (t: TSource) => boolean | Promise<boolean>): Evaluator<TSource, number>;
export declare function sum<TSource>(): TSource extends number ? Promise<number> : never;
export declare function sum<TSource>(selector?: (t: TSource) => number | Promise<number>): Evaluator<TSource, number>;
export declare function min<TSource>(): TSource extends number ? Promise<number> : never;
export declare function min<TSource>(selector?: (t: TSource) => number | Promise<number>): Evaluator<TSource, number>;
export declare function max<TSource>(): TSource extends number ? Promise<number> : never;
export declare function max<TSource>(selector?: (t: TSource) => number | Promise<number>): Evaluator<TSource, number>;
export declare function average<TSource>(): TSource extends number ? Promise<number> : never;
export declare function average<TSource>(selector?: (t: TSource) => number | Promise<number>): Evaluator<TSource, number>;
export declare function aggregate<TSource, TAccumulate>(seed: TAccumulate, func: (acc: TAccumulate, t: TSource) => TAccumulate | Promise<TAccumulate>): Evaluator<TSource, TAccumulate>;
export declare function zip<TSource1, TSource2, TResult = [TSource1, TSource2]>(source1: AsyncIterableIterator<TSource1>, source2: AsyncIterableIterator<TSource2>, resultSelector?: (t1: TSource1, t2: TSource2) => TResult | Promise<TResult>): AsyncIterableIterator<TResult>;
