import { IterableBase } from "./base";
import { AsyncIterableIterator, AsyncQueryable, AsyncQueryableGrouping, AsyncQuerySource, Operator, OrderKey } from "./interfaces";
export declare class AsyncQueryableImpl<TSource> extends IterableBase<TSource> implements AsyncQueryable<TSource> {
    static from<TSource>(source: AsyncQuerySource<TSource>): AsyncQueryableImpl<TSource>;
    protected constructor(source: AsyncIterableIterator<TSource>);
    filter(f: (t: TSource, i: number) => boolean): AsyncQueryable<TSource>;
    flatMap<TInner, TResult = TInner>(selector: (t: TSource, index: number) => AsyncQuerySource<TInner>, resultSelector?: (t: TSource, ti: TInner) => TResult | Promise<TResult>): AsyncQueryable<TResult>;
    map<TResult>(f: (t: TSource, i: number) => TResult | Promise<TResult>): AsyncQueryable<TResult>;
    skip(n: number): AsyncQueryable<TSource>;
    skipWhile(predicate: (t: TSource, i: number) => boolean | Promise<boolean>): AsyncQueryable<TSource>;
    take(n: number): AsyncQueryable<TSource>;
    takeWhile(predicate: (t: TSource, i: number) => boolean | Promise<boolean>): AsyncQueryable<TSource>;
    join<TInner, TKey, TResult>(inner: AsyncQuerySource<TInner>, outerKeySelector: (to: TSource) => TKey | Promise<TKey>, innerKeySelector: (ti: TInner) => TKey | Promise<TKey>, resultSelector: (to: TSource, ti: TInner) => TResult | Promise<TResult>): AsyncQueryable<TResult>;
    groupJoin<TInner, TKey, TResult>(inner: AsyncQuerySource<TInner>, outerKeySelector: (to: TSource) => TKey | Promise<TKey>, innerKeySelector: (ti: TInner) => TKey | Promise<TKey>, resultSelector: (to: TSource, ti: AsyncQuerySource<TInner>) => TResult | Promise<TResult>): AsyncQueryable<TResult>;
    concat(iter: AsyncQuerySource<TSource>): AsyncQueryable<TSource>;
    reverse(): AsyncQueryable<TSource>;
    orderBy(keySelector: (t: TSource) => OrderKey | Promise<OrderKey>): AsyncQueryable<TSource>;
    orderByDescending(keySelector: (t: TSource) => OrderKey | Promise<OrderKey>): AsyncQueryable<TSource>;
    groupBy<TKey, TResult = TSource>(keySelector: (t: TSource) => TKey | Promise<TKey>, elementSelector?: (t: TSource) => TResult | Promise<TResult>): AsyncQueryable<AsyncQueryableGrouping<TKey, TResult>>;
    distinct(): AsyncQueryable<TSource>;
    union(second: AsyncQuerySource<TSource>): AsyncQueryable<TSource>;
    intersect(second: AsyncQuerySource<TSource>): AsyncQueryable<TSource>;
    except(second: AsyncQuerySource<TSource>): AsyncQueryable<TSource>;
    first(predicate?: (t: TSource) => boolean | Promise<boolean>): Promise<TSource>;
    firstOrDefault(defaultValue: TSource, predicate?: (t: TSource) => boolean | Promise<boolean>): Promise<TSource>;
    last(predicate?: (t: TSource) => boolean | Promise<boolean>): Promise<TSource>;
    lastOrDefault(defaultValue: TSource, predicate?: (t: TSource) => boolean | Promise<boolean>): Promise<TSource>;
    single(predicate?: (t: TSource) => boolean | Promise<boolean>): Promise<TSource>;
    singleOrDefault(defaultValue: TSource, predicate?: (t: TSource) => boolean | Promise<boolean>): Promise<TSource>;
    elementAt(index: number): Promise<TSource>;
    elementAtOrDefault(defaultValue: TSource, index: number): Promise<TSource>;
    defaultIfEmpty(defaultValue: TSource): AsyncQueryable<TSource>;
    any(predicate?: (t: TSource) => boolean | Promise<boolean>): Promise<boolean>;
    all(predicate: (t: TSource) => boolean | Promise<boolean>): Promise<boolean>;
    contains(value: TSource): Promise<boolean>;
    count(predicate?: (t: TSource) => boolean | Promise<boolean>): Promise<number>;
    sum(): TSource extends number ? Promise<number> : never;
    sum(selector?: (t: TSource) => number | Promise<number>): Promise<number>;
    min(): TSource extends number ? Promise<number> : never;
    min(selector?: (t: TSource) => number | Promise<number>): Promise<number>;
    max(): TSource extends number ? Promise<number> : never;
    max(selector?: (t: TSource) => number | Promise<number>): Promise<number>;
    average(): TSource extends number ? Promise<number> : never;
    average(selector?: (t: TSource) => number | Promise<number>): Promise<number>;
    aggregate<TAccumulate>(seed: TAccumulate, func: (acc: TAccumulate, t: TSource) => TAccumulate | Promise<TAccumulate>): Promise<TAccumulate>;
    toArray(): Promise<TSource[]>;
    toMap<TKey, TResult = TSource>(keySelector: (t: TSource) => TKey | Promise<TKey>, elementSelector: (t: TSource) => TResult | Promise<TResult>): Promise<Map<TKey, TResult>>;
    ofType<TResult>(typeGuard: (o: any) => o is TResult): AsyncQueryable<TResult>;
    forEach(f: (t: TSource) => void | Promise<void>): Promise<void>;
    pipe(): AsyncQueryable<TSource>;
    pipe<TResult>(op: Operator<TSource, TResult>): AsyncQueryable<TResult>;
    pipe<TResult1, TResult2>(op1: Operator<TSource, TResult1>, op2: Operator<TResult1, TResult2>): AsyncQueryable<TResult2>;
    pipe<TResult1, TResult2, TResult3>(op1: Operator<TSource, TResult1>, op2: Operator<TResult1, TResult2>, op3: Operator<TResult2, TResult3>): AsyncQueryable<TResult3>;
    pipe<TResult1, TResult2, TResult3, TResult4>(op1: Operator<TSource, TResult1>, op2: Operator<TResult1, TResult2>, op3: Operator<TResult2, TResult3>, op4: Operator<TResult3, TResult4>): AsyncQueryable<TResult4>;
    pipe<TResult1, TResult2, TResult3, TResult4, TResult5>(op1: Operator<TSource, TResult1>, op2: Operator<TResult1, TResult2>, op3: Operator<TResult2, TResult3>, op4: Operator<TResult3, TResult4>, op5: Operator<TResult4, TResult5>): AsyncQueryable<TResult5>;
    pipe<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6>(op1: Operator<TSource, TResult1>, op2: Operator<TResult1, TResult2>, op3: Operator<TResult2, TResult3>, op4: Operator<TResult3, TResult4>, op5: Operator<TResult4, TResult5>, op6: Operator<TResult5, TResult6>): AsyncQueryable<TResult6>;
    pipe<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6, TResult7>(op1: Operator<TSource, TResult1>, op2: Operator<TResult1, TResult2>, op3: Operator<TResult2, TResult3>, op4: Operator<TResult3, TResult4>, op5: Operator<TResult4, TResult5>, op6: Operator<TResult5, TResult6>, op7: Operator<TResult6, TResult7>): AsyncQueryable<TResult7>;
    pipe<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6, TResult7, TResult8>(op1: Operator<TSource, TResult1>, op2: Operator<TResult1, TResult2>, op3: Operator<TResult2, TResult3>, op4: Operator<TResult3, TResult4>, op5: Operator<TResult4, TResult5>, op6: Operator<TResult5, TResult6>, op7: Operator<TResult6, TResult7>, op8: Operator<TResult7, TResult8>): AsyncQueryable<TResult8>;
    pipe<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6, TResult7, TResult8, TResult9>(op1: Operator<TSource, TResult1>, op2: Operator<TResult1, TResult2>, op3: Operator<TResult2, TResult3>, op4: Operator<TResult3, TResult4>, op5: Operator<TResult4, TResult5>, op6: Operator<TResult5, TResult6>, op7: Operator<TResult6, TResult7>, op8: Operator<TResult7, TResult8>, op9: Operator<TResult8, TResult9>, ...ops: Operator<any, any>[]): AsyncQueryable<TResult9>;
}
export declare class GroupingImpl<TKey, TSource> extends AsyncQueryableImpl<TSource> implements AsyncQueryableGrouping<TKey, TSource> {
    readonly key: TKey;
    constructor(key: TKey, group: AsyncIterableIterator<TSource>);
}
