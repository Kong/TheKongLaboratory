"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("./base");
const operators_1 = require("./operators");
const sources_1 = require("./sources");
class AsyncQueryableImpl extends base_1.IterableBase {
    constructor(source) {
        super(source);
    }
    //
    // Constructors.
    //
    static from(source) {
        return new AsyncQueryableImpl(sources_1.from(source));
    }
    //
    // Restriction operators.
    //
    filter(f) {
        return this.pipe(operators_1.filter(f));
    }
    //
    // Projection operators.
    //
    flatMap(selector, resultSelector = (t, ti) => ti) {
        return this.pipe(operators_1.flatMap(selector, resultSelector));
    }
    map(f) {
        return this.pipe(operators_1.map(f));
    }
    //
    // Partitioning operators.
    //
    skip(n) {
        return this.pipe(operators_1.skip(n));
    }
    skipWhile(predicate) {
        return this.pipe(operators_1.skipWhile(predicate));
    }
    take(n) {
        return this.pipe(operators_1.take(n));
    }
    takeWhile(predicate) {
        return this.pipe(operators_1.takeWhile(predicate));
    }
    //
    // Join operators.
    //
    join(inner, outerKeySelector, innerKeySelector, resultSelector) {
        return this.pipe(operators_1.join(sources_1.from(inner), outerKeySelector, innerKeySelector, resultSelector));
    }
    groupJoin(inner, outerKeySelector, innerKeySelector, resultSelector) {
        return this.pipe(operators_1.groupJoin(sources_1.from(inner), outerKeySelector, innerKeySelector, resultSelector));
    }
    //
    // Concatenation operators.
    //
    concat(iter) {
        return this.pipe(operators_1.concat(sources_1.from(iter)));
    }
    //
    // Ordering operators.
    //
    reverse() {
        return this.pipe(operators_1.reverse());
    }
    orderBy(keySelector) {
        return this.pipe(operators_1.orderBy(keySelector));
    }
    orderByDescending(keySelector) {
        return this.pipe(operators_1.orderByDescending(keySelector));
    }
    //
    // Grouping operators.
    //
    groupBy(keySelector, elementSelector) {
        return this.pipe(function (source) {
            return __asyncGenerator(this, arguments, function* () {
                var e_1, _a;
                const groups = yield __await(operators_1.groupBy(keySelector, elementSelector)(source));
                try {
                    for (var groups_1 = __asyncValues(groups), groups_1_1; groups_1_1 = yield __await(groups_1.next()), !groups_1_1.done;) {
                        const group = groups_1_1.value;
                        yield yield __await(new GroupingImpl(group.key, sources_1.from(group)));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (groups_1_1 && !groups_1_1.done && (_a = groups_1.return)) yield __await(_a.call(groups_1));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            });
        });
    }
    //
    // Set operators.
    //
    distinct() {
        return this.pipe(operators_1.distinct());
    }
    union(second) {
        return this.pipe(operators_1.union(sources_1.from(second)));
    }
    intersect(second) {
        return this.pipe(operators_1.intersect(sources_1.from(second)));
    }
    except(second) {
        return this.pipe(operators_1.except(sources_1.from(second)));
    }
    //
    // Element operators.
    //
    first(predicate) {
        return operators_1.first(predicate)(this);
    }
    firstOrDefault(defaultValue, predicate) {
        return operators_1.firstOrDefault(defaultValue, predicate)(this);
    }
    last(predicate) {
        return operators_1.last(predicate)(this);
    }
    lastOrDefault(defaultValue, predicate) {
        return operators_1.lastOrDefault(defaultValue, predicate)(this);
    }
    single(predicate) {
        return operators_1.single(predicate)(this);
    }
    singleOrDefault(defaultValue, predicate) {
        return operators_1.singleOrDefault(defaultValue, predicate)(this);
    }
    elementAt(index) {
        return operators_1.elementAt(index)(this);
    }
    elementAtOrDefault(defaultValue, index) {
        return operators_1.elementAtOrDefault(defaultValue, index)(this);
    }
    defaultIfEmpty(defaultValue) {
        return this.pipe(operators_1.defaultIfEmpty(defaultValue));
    }
    //
    // Quantifiers.
    //
    any(predicate) {
        return operators_1.any(predicate)(this);
    }
    all(predicate) {
        return operators_1.all(predicate)(this);
    }
    contains(value) {
        return operators_1.contains(value)(this);
    }
    //
    // Aggregate operators.
    //
    count(predicate) {
        return operators_1.count(predicate)(this);
    }
    sum(selector) {
        return operators_1.sum(selector)(this);
    }
    min(selector) {
        return operators_1.min(selector)(this);
    }
    max(selector) {
        return operators_1.max(selector)(this);
    }
    average(selector) {
        return operators_1.average(selector)(this);
    }
    aggregate(seed, func) {
        return operators_1.aggregate(seed, func)(this);
    }
    //
    // Eval operators.
    //
    toArray() {
        return __awaiter(this, void 0, void 0, function* () {
            return operators_1.toArray()(this);
        });
    }
    toMap(keySelector, elementSelector) {
        return operators_1.toMap(keySelector, elementSelector)(this);
    }
    ofType(typeGuard) {
        return this.pipe(operators_1.ofType(typeGuard));
    }
    forEach(f) {
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (var _b = __asyncValues(this), _c; _c = yield _b.next(), !_c.done;) {
                    const t = _c.value;
                    f(t);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    pipe(...ops) {
        return new AsyncQueryableImpl((function (source) {
            return __asyncGenerator(this, arguments, function* () {
                var e_3, _a;
                let newSource = source;
                for (const op of ops) {
                    newSource = op(newSource);
                }
                try {
                    for (var newSource_1 = __asyncValues(newSource), newSource_1_1; newSource_1_1 = yield __await(newSource_1.next()), !newSource_1_1.done;) {
                        const t = newSource_1_1.value;
                        yield yield __await(t);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (newSource_1_1 && !newSource_1_1.done && (_a = newSource_1.return)) yield __await(_a.call(newSource_1));
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            });
        })(this));
    }
}
exports.AsyncQueryableImpl = AsyncQueryableImpl;
class GroupingImpl extends AsyncQueryableImpl {
    constructor(key, group) {
        super(group);
        this.key = key;
    }
}
exports.GroupingImpl = GroupingImpl;
