"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
//
// NOTE: We choose to be purposefully conservative about what details are exposed through these
// interfaces in case we decide to change the implementation drastically later.
//
//
// Polyfill the async iterator per the "caveats" section of the feature release notes:
// https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#the-for-await-of-statement
//
if (typeof Symbol.asyncIterator === "undefined") {
    Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");
}
const asyncQueryable_1 = require("./asyncQueryable");
const sources = require("./sources");
/**
 * Creates an `AsyncQueryable` from things that look `Iterable` or `AsyncIterable`, even if they're
 * wrapped in a `Promise`.
 * @param source Object to convert into an `AsyncQueryable`.
 */
function from(source) {
    return asyncQueryable_1.AsyncQueryableImpl.from(source);
}
exports.from = from;
/**
 * Generates a (potentially infinite) sequence of integral numbers within a range. The first number
 * emitted is `start`, and the last is `stop - 1`. If the enumerated sequence generates zero
 * elements (for example, when `stop <= start + 1`), an exception is thrown.
 * @param start Beginning of the range
 * @param stop Non-inclusive end of the range.
 * @example
 * const squares = await range(0, 3).map(x => x * x).toArray(); // == [0, 1, 4]
 */
function range(start, stop) {
    return asyncQueryable_1.AsyncQueryableImpl.from(sources.range(start, stop));
}
exports.range = range;
/**
 * Returns an empty sequence of `TResult`.
 * @example
 * const noNumbers = await empty<number>().toArray(); // == []
 */
function empty() {
    return asyncQueryable_1.AsyncQueryableImpl.from(sources.from([]));
}
exports.empty = empty;
/**
 * Generates a (potentially infinite) sequence by repeating a single value.
 * @param t Object to repeat
 * @example
 * const ones = await repeat(1).take(3).toArray(); // == [1, 1, 1]
 */
function repeat(t /* TODO: add optional count. */) {
    asyncQueryable_1.AsyncQueryableImpl.from((function () {
        return __asyncGenerator(this, arguments, function* () {
            while (true) {
                yield yield __await(t);
            }
        });
    })());
}
exports.repeat = repeat;
