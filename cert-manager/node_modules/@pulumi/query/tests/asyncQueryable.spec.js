"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const __1 = require("..");
const asyncQueryable_1 = require("../asyncQueryable");
function assertRejects(done, p) {
    p.then(() => {
        done(new Error("Expected method to reject."));
    })
        .catch(err => {
        assert.notDeepEqual(err, undefined);
        done();
    })
        .catch(done);
}
describe("IterablePromise sources", () => {
    describe("range", () => {
        //
        // TODO: Throw error when range overlaps.
        //
        it("produces an empty array for overlapping ranges", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield __1.range(0, 0).toArray();
            assert.deepEqual(xs, []);
            xs = yield __1.range(0, -1).toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces an array of one for boundary case", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield __1.range(0, 1).toArray();
            assert.deepEqual(xs, [0]);
        }));
        it("can produce a range including negative numbers", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield __1.range(-3, 2).toArray();
            assert.deepEqual(xs, [-3, -2, -1, 0, 1]);
        }));
        it("is lazily evaluated by take when range is infinite", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield __1.range(0)
                .take(5)
                .toArray();
            assert.deepEqual(xs, [0, 1, 2, 3, 4]);
        }));
        it("is lazily transformed and filtered when range is infinite", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield __1.range(0)
                .map(x => x + 2)
                // If filter is bigger than the take window, we enumerate all numbers and hang
                // forever.
                .filter(x => x <= 10)
                .take(7)
                .map(x => x - 2)
                .filter(x => x > 3)
                .toArray();
            assert.deepEqual(xs, [4, 5, 6]);
        }));
        it("is lazily flatMap'd when range is infinite", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield __1.range(0)
                // If filter is bigger than the take window, we enumerate all numbers and hang
                // forever.
                .flatMap(x => (x <= 10 ? [x, x] : []))
                .take(5)
                .toArray();
            assert.deepEqual(xs, [0, 0, 1, 1, 2]);
        }));
    });
});
describe("IterablePromise restriction operators", () => {
    describe("filter", () => {
        it("produces [] when all elements are filtered out", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .filter(x => x < 0)
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces an non-empty array when some elements are filtered out", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .filter(x => x >= 3)
                .toArray();
            assert.deepEqual(xs, [3, 4]);
        }));
    });
});
describe("IterablePromise projection operators", () => {
    describe("map", () => {
        it("x => x does identity transformation", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .map(x => x)
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4]);
        }));
        it("x => x+1 adds one to every element", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .map(x => x + 1)
                .toArray();
            assert.deepEqual(xs, [2, 3, 4, 5]);
        }));
    });
    describe("flatMap", () => {
        it("produces [] when all elements are filtered out", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .flatMap(x => [])
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("can add elements to an enumerable", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .flatMap(x => [x, x])
                .toArray();
            assert.deepEqual(xs, [1, 1, 2, 2, 3, 3, 4, 4]);
        }));
    });
});
describe("IterablePromise partitioning operators", () => {
    describe("skip", () => {
        it("produces [] when all elements are skipped", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .skip(4)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .skip(4)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })())
                .skip(4)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .skip(0)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })())
                .skip(0)
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty array when not all elements are skipped", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .skip(4)
                .toArray();
            assert.deepEqual(xs, [5]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .skip(0)
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4, 5]);
        }));
        it("throws exception when negative number is provided for n, part 1", () => __awaiter(this, void 0, void 0, function* () {
            try {
                asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                    .skip(-1)
                    .toArray();
            }
            catch (e) {
                return;
            }
            assert.fail();
        }));
        it("throws exception when negative number is provided for n, part 2", () => __awaiter(this, void 0, void 0, function* () {
            try {
                asyncQueryable_1.AsyncQueryableImpl.from([])
                    .skip(-1)
                    .toArray();
            }
            catch (e) {
                return;
            }
        }));
    });
    describe("skipWhile", () => {
        it("produces [] when all elements are skipped", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .skipWhile(x => true)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .skipWhile(x => false)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .skipWhile(x => true)
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty array when not all elements are skipped", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .skipWhile(x => x < 2)
                .toArray();
            assert.deepEqual(xs, [2, 3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .skipWhile((x, i) => i < 1)
                .toArray();
            assert.deepEqual(xs, [2, 3, 4]);
        }));
        it("does not invoke the predicate again after it returns false one time", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .skipWhile(x => x < 2 || x > 3)
                .toArray();
            assert.deepEqual(xs, [2, 3, 4, 5]);
        }));
    });
    describe("take", () => {
        it("produces [] when no elements are taken", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .take(0)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .take(4)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .take(0)
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty array when some elements are taken", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .take(4)
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .take(8)
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4, 5]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .take(5)
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4, 5]);
        }));
        it("throws exception when negative number is provided for n, part 1", () => __awaiter(this, void 0, void 0, function* () {
            try {
                yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                    .take(-1)
                    .toArray();
            }
            catch (e) {
                return;
            }
            assert.fail();
        }));
        it("throws exception when negative number is provided for n, part 2", () => __awaiter(this, void 0, void 0, function* () {
            try {
                yield asyncQueryable_1.AsyncQueryableImpl.from([])
                    .take(-1)
                    .toArray();
            }
            catch (e) {
                return;
            }
            assert.fail();
        }));
    });
    describe("takeWhile", () => {
        it("produces [] when no elements are taken", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .takeWhile(x => false)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .takeWhile(x => true)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .takeWhile(x => false)
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty array when some elements are taken", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .takeWhile(x => x <= 2)
                .toArray();
            assert.deepEqual(xs, [1, 2]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .takeWhile((x, i) => i <= 1)
                .toArray();
            assert.deepEqual(xs, [1, 2]);
        }));
        it("does not invoke the predicate again after it returns false one time", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .takeWhile(x => x <= 2 || x > 4)
                .toArray();
            assert.deepEqual(xs, [1, 2]);
        }));
    });
});
describe("IterablePromise join operators", () => {
    describe("join", () => {
        it("produces [] when no elements are taken", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .join([1, 2, 3], x => x, x => x, (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .join([], x => x, x => x, (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("joins non-empty sets", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .join([1, 2, 3], x => x, x => x, (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, [[1, 1], [2, 2], [3, 3]]);
        }));
        it("ignores joins when key selector produces undefined", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .join([1, 2, 3], x => (x === 2 ? undefined : x), x => x, (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, [[1, 1], [3, 3]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .join([1, 2, 3], x => x, x => (x === 2 ? undefined : x), (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, [[1, 1], [3, 3]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .join([1, 2, 3], x => (x === 2 ? null : x), x => x, (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, [[1, 1], [3, 3]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5])
                .join([1, 2, 3], x => x, x => (x === 2 ? null : x), (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, [[1, 1], [3, 3]]);
        }));
        it("joins multiple inner records to one outer record", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 2, 3, 4, 5])
                .join([1, 2], x => x, x => x, (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, [[1, 1], [2, 2], [2, 2]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .join([1, 2, 2, 3, 4, 5], x => x, x => x, (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, [[1, 1], [2, 2], [2, 2]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 2])
                .join([1, 2, 2, 3, 4, 5], x => x, x => x, (x, y) => [x, y])
                .toArray();
            assert.deepEqual(xs, [[1, 1], [2, 2], [2, 2], [2, 2], [2, 2]]);
        }));
    });
});
describe("IterablePromise concatenation operators", () => {
    describe("concat", () => {
        //
        // These tests exist, in part, to make sure that type inference works for the complex types
        // in the signatures of `concat` and `from`.
        //
        it("concats T[]", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .concat([3, 4])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .concat([3, 4])
                .toArray();
            assert.deepEqual(xs, [3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .concat([])
                .toArray();
            assert.deepEqual(xs, [1, 2]);
        }));
        it("concats Promise<T[]>", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from(Promise.resolve([1, 2]))
                .concat([3, 4])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .concat(Promise.resolve([3, 4]))
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from(Promise.resolve([]))
                .concat([3, 4])
                .toArray();
            assert.deepEqual(xs, [3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .concat(Promise.resolve([3, 4]))
                .toArray();
            assert.deepEqual(xs, [3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from(Promise.resolve([1, 2]))
                .concat([])
                .toArray();
            assert.deepEqual(xs, [1, 2]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .concat(Promise.resolve([]))
                .toArray();
            assert.deepEqual(xs, [1, 2]);
        }));
        it("concats iterators", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2]) {
                    yield x;
                }
            })())
                .concat([3, 4])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .concat((function* () {
                for (const x of [3, 4]) {
                    yield x;
                }
            })())
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })())
                .concat([3, 4])
                .toArray();
            assert.deepEqual(xs, [3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .concat((function* () {
                for (const x of [3, 4]) {
                    yield x;
                }
            })())
                .toArray();
            assert.deepEqual(xs, [3, 4]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2]) {
                    yield x;
                }
            })())
                .concat([])
                .toArray();
            assert.deepEqual(xs, [1, 2]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .concat((function* () {
                for (const x of []) {
                    yield x;
                }
            })())
                .toArray();
            assert.deepEqual(xs, [1, 2]);
        }));
    });
});
describe("IterablePromise ordering operators", () => {
    describe("reverse", () => {
        it("produces [] for empty array", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .reverse()
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })())
                .reverse()
                .toArray();
            assert.deepEqual(xs, []);
        }));
    });
    describe("orderBy", () => {
        it("correctly sorts number keys", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .orderBy(x => x)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([2, 3, 1, 14])
                .orderBy(x => x)
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 14]);
        }));
        it("lexically sorts string keys", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([2, 3, 1, 14])
                .orderBy(x => x.toString())
                .toArray();
            assert.deepEqual(xs, [1, 14, 2, 3]);
        }));
        it("rejects if key function returns something other than number | string", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([2, 3, 1, 14])
                .orderBy(() => [2])
                .toArray());
        });
        it("rejects if key function does not return only keys of one type", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([2, 3, 1, 14])
                .orderBy(x => {
                if (x === 2) {
                    return "2";
                }
                return x;
            })
                .toArray());
        });
    });
});
describe("IterablePromise grouping operators", () => {
    describe("groupBy", () => {
        it("produces [] for empty array", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .groupBy(x => x)
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })())
                .groupBy(x => x)
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty groups when array is not empty", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1])
                .groupBy(x => x)
                .map(g => g.toArray())
                .toArray();
            assert.deepEqual(xs, [[1]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1]) {
                    yield x;
                }
            })())
                .groupBy(x => x)
                .map(g => g.toArray())
                .toArray();
            assert.deepEqual(xs, [[1]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .groupBy(x => x)
                .map(g => g.toArray())
                .toArray();
            assert.deepEqual(xs, [[1], [2]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2]) {
                    yield x;
                }
            })())
                .groupBy(x => x)
                .map(g => g.toArray())
                .toArray();
            assert.deepEqual(xs, [[1], [2]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 1])
                .groupBy(x => x)
                .map(g => g.toArray())
                .toArray();
            assert.deepEqual(xs, [[1, 1], [2]]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 1]) {
                    yield x;
                }
            })())
                .groupBy(x => x)
                .map(g => g.toArray())
                .toArray();
            assert.deepEqual(xs, [[1, 1], [2]]);
            const ys = yield asyncQueryable_1.AsyncQueryableImpl.from([
                { foo: "bar", bar: 1 },
                { foo: "baz" },
                { foo: undefined },
                { foo: "bar", bar: 2 },
            ])
                .groupBy(x => x.foo)
                .map(g => g.toArray())
                .toArray();
            assert.deepEqual(ys, [
                [{ foo: "bar", bar: 1 }, { foo: "bar", bar: 2 }],
                [{ foo: "baz" }],
                [{ foo: undefined }],
            ]);
        }));
        it("produces projected elements when result selector is used", () => __awaiter(this, void 0, void 0, function* () {
            const ys = yield asyncQueryable_1.AsyncQueryableImpl.from([
                { foo: "bar", bar: 1 },
                { foo: "baz" },
                { foo: undefined },
                { foo: "bar", bar: 2 },
            ])
                .groupBy(x => x.foo, x => x.foo)
                .map(g => g.toArray())
                .toArray();
            assert.deepEqual(ys, [["bar", "bar"], ["baz"], [undefined]]);
        }));
    });
});
describe("IterablePromise set operators", () => {
    describe("distinct", () => {
        it("produces [] for empty array", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .distinct()
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty set when array is not empty", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .distinct()
                .toArray();
            assert.deepEqual(xs, [1, 2, 3]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 1, 1, 2, 3, 1, 1])
                .distinct()
                .toArray();
            assert.deepEqual(xs, [1, 2, 3]);
        }));
    });
    describe("union", () => {
        it("produces [] for empty array", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .union([])
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty set when array is not empty", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .union([])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .union([1, 1, 1, 2, 3, 1, 1])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .union([1, 1, 1, 2, 3, 1, 1])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 1, 1, 2, 3, 1, 1])
                .union([1, 2, 3])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 1, 1, 2, 3, 1, 1, 4, 4, 5, 4])
                .union([1, 2, 3])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3, 4, 5]);
        }));
    });
    describe("intersect", () => {
        it("produces [] when there is no set intersection", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .intersect([])
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .intersect([])
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .intersect([1, 2, 3])
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .intersect([4, 5, 6])
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty set when intersection is not empty", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .intersect([1])
                .toArray();
            assert.deepEqual(xs, [1]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .intersect([1, 1, 1, 2, 3, 1, 1])
                .toArray();
            assert.deepEqual(xs, [1, 2]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 1, 1, 2, 3, 1, 1])
                .intersect([1, 2])
                .toArray();
            assert.deepEqual(xs, [1, 2]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 1, 1, 2, 3, 1, 1])
                .intersect([1, 2, 3])
                .toArray();
            assert.deepEqual(xs, [1, 2, 3]);
        }));
    });
    describe("except", () => {
        it("produces [] when there is no set difference", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .except([])
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .except([1, 2, 3])
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .except([1, 1, 1, 2, 3, 1, 1])
                .toArray();
            assert.deepEqual(xs, []);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 1, 1, 2, 3, 1, 1])
                .except([1, 2, 3])
                .toArray();
            assert.deepEqual(xs, []);
        }));
        it("produces non-empty set when set difference is not empty", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .except([1])
                .toArray();
            assert.deepEqual(xs, [2, 3]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2])
                .except([1, 1, 1, 2, 3, 1, 1])
                .toArray();
            assert.deepEqual(xs, [3]);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 1, 1, 2, 3, 1, 1])
                .except([1, 2])
                .toArray();
            assert.deepEqual(xs, [3]);
        }));
    });
});
describe("IterablePromise element operators", () => {
    describe("first", () => {
        it("throws error if enumerable is empty", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([]).first());
        });
        it("throws error if predicate specifies non-existent element", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).first(x => x === 4));
        });
        it("finds first element of sequence", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).first();
            assert.deepEqual(xs, 1);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).first();
            assert.deepEqual(xs, 1);
        }));
    });
    describe("firstOrDefault", () => {
        it("default value populated if enumerable is empty", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([]).firstOrDefault(99);
            assert.deepEqual(xs, 99);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })()).firstOrDefault(99);
            assert.deepEqual(xs, 99);
        }));
        it("default value if predicate specifies non-existent element", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).firstOrDefault(99, x => x === 4);
            assert.deepEqual(xs, 99);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).firstOrDefault(99, x => x === 4);
            assert.deepEqual(xs, 99);
        }));
        it("finds first element of sequence", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).firstOrDefault(99);
            assert.deepEqual(xs, 1);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).firstOrDefault(99);
            assert.deepEqual(xs, 1);
        }));
    });
    describe("last", () => {
        it("throws error if enumerable is empty", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([]).last());
        });
        it("throws error if predicate specifies non-existent element", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).last(x => x === 4));
        });
        it("finds last element of sequence", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).last();
            assert.deepEqual(xs, 3);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).last();
            assert.deepEqual(xs, 3);
        }));
    });
    describe("lastOrDefault", () => {
        it("default value populated if enumerable is empty", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([]).lastOrDefault(99);
            assert.deepEqual(xs, 99);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })()).lastOrDefault(99);
            assert.deepEqual(xs, 99);
        }));
        it("default value if predicate specifies non-existent element", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).firstOrDefault(99, x => x === 4);
            assert.deepEqual(xs, 99);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).firstOrDefault(99, x => x === 4);
            assert.deepEqual(xs, 99);
        }));
        it("finds first element of sequence", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).lastOrDefault(99);
            assert.deepEqual(xs, 3);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).lastOrDefault(99);
            assert.deepEqual(xs, 3);
        }));
    });
    describe("single", () => {
        it("throws error if enumerable is empty", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([]).single());
        });
        it("throws error if enumerable has more than 1 element", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([1, 2]).single());
        });
        it("throws error if predicate specifies non-existent element", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).single(x => x === 4));
        });
        it("throws error if predicate specifies multiple elements", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 2, 3]).single(x => x === 2));
        });
        it("finds single element of sequence", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).single(x => x === 2);
            assert.deepEqual(xs, 2);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).single(x => x === 2);
            assert.deepEqual(xs, 2);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1]).single();
            assert.deepEqual(xs, 1);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1]) {
                    yield x;
                }
            })()).single();
            assert.deepEqual(xs, 1);
        }));
    });
    describe("singleOrDefault", () => {
        it("default value if enumerable is empty", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([]).singleOrDefault(99);
            assert.deepEqual(xs, 99);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [99]) {
                    yield x;
                }
            })()).singleOrDefault(99);
            assert.deepEqual(xs, 99);
        }));
        it("throw error if enumerable has more than 1 element and default predicate", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([1, 2]).singleOrDefault(99));
        });
        it("default value if predicate specifies non-existent element", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).singleOrDefault(99, x => x === 4);
            assert.deepEqual(xs, 99);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).singleOrDefault(99, x => x === 4);
            assert.deepEqual(xs, 99);
        }));
        it("throws error if predicate specifies multiple elements", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 2, 3]).singleOrDefault(99, x => x === 2));
        });
        it("finds single element of sequence", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).singleOrDefault(99, x => x === 2);
            assert.deepEqual(xs, 2);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).singleOrDefault(99, x => x === 2);
            assert.deepEqual(xs, 2);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1]).singleOrDefault(99);
            assert.deepEqual(xs, 1);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1]) {
                    yield x;
                }
            })()).singleOrDefault(99);
            assert.deepEqual(xs, 1);
        }));
    });
    describe("elementAt", () => {
        it("finds element at in-range index", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).elementAt(1);
            assert.deepEqual(xs, 2);
        }));
        it("throws error if index is out-of-range", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).elementAt(3));
        });
        it("throws error if index is out-of-range", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([]).elementAt(0));
        });
        it("throws error if index is out-of-range", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([]).elementAt(-1));
        });
        it("throws error if index is out-of-range", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1]) {
                    yield x;
                }
            })()).elementAt(-1));
        });
    });
    describe("elementAtOrDefault", () => {
        it("finds element at in-range index", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).elementAtOrDefault(99, 1);
            assert.deepEqual(xs, 2);
        }));
        it("default value if index is out-of-range", () => __awaiter(this, void 0, void 0, function* () {
            let xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).elementAtOrDefault(99, 3);
            assert.deepEqual(xs, 99);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([]).elementAtOrDefault(99, 0);
            assert.deepEqual(xs, 99);
            xs = yield asyncQueryable_1.AsyncQueryableImpl.from([]).elementAtOrDefault(99, -1);
            assert.deepEqual(xs, 99);
        }));
    });
    describe("defaultIfEmpty", () => {
        it("default value if empty", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([])
                .defaultIfEmpty(99)
                .toArray();
            assert.deepEqual(xs, [99]);
        }));
        it("identity if not empty", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3])
                .defaultIfEmpty(99)
                .toArray();
            assert.deepEqual(xs, [1, 2, 3]);
        }));
    });
});
describe("IterablePromise quantifier operators", () => {
    describe("any", () => {
        it("false if nothing satisfies predicate", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([]).any(x => x > 3);
            assert.deepEqual(res, false);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([1]).any(x => x > 3);
            assert.deepEqual(res, false);
        }));
        it("true if >= 1 thing satisfies predicate", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([4]).any(x => x > 3);
            assert.deepEqual(res, true);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([4, 5]).any(x => x > 3);
            assert.deepEqual(res, true);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([3, 4, 5]).any(x => x > 3);
            assert.deepEqual(res, true);
        }));
    });
    describe("all", () => {
        it("empty sequence satisfies predicate", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([]).all(x => x > 3);
            assert.deepEqual(res, true);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })()).all(x => x > 3);
            assert.deepEqual(res, true);
        }));
        it("returns false when not everything satisfies predicate", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3]).all(x => x > 2);
            assert.deepEqual(res, false);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [1, 2, 3]) {
                    yield x;
                }
            })()).all(x => x > 2);
            assert.deepEqual(res, false);
        }));
        it("returns false when not everything satisfies predicate", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([2, 3]).all(x => x >= 2);
            assert.deepEqual(res, true);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of [2, 3]) {
                    yield x;
                }
            })()).all(x => x >= 2);
            assert.deepEqual(res, true);
        }));
    });
    describe("contains", () => {
        it("returns true if sequence contains value", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([]).contains(3);
            assert.deepEqual(res, false);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2]).contains(3);
            assert.deepEqual(res, false);
        }));
        it("returns true if sequence contains value", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([3]).contains(3);
            assert.deepEqual(res, true);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([2, 3, 4]).contains(3);
            assert.deepEqual(res, true);
        }));
    });
});
describe("IterablePromise aggregate operators", () => {
    describe("count", () => {
        it("returns 0 for empty lists", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([]).count();
            assert.deepEqual(res, 0);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from((function* () {
                for (const x of []) {
                    yield x;
                }
            })()).count();
            assert.deepEqual(res, 0);
        }));
        it("returns > 1 count for non-empty lists", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([1]).count();
            assert.deepEqual(res, 1);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2]).count();
            assert.deepEqual(res, 2);
        }));
    });
    describe("sum", () => {
        it("returns 0 for empty array", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield asyncQueryable_1.AsyncQueryableImpl.from([]).sum();
            assert.deepEqual(res, 0);
        }));
        it("correctly calculates the sum of array of numbers", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4, 5]).sum();
            assert.deepEqual(res, 15);
        }));
        it("throws when summing non-numbers", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).sum());
        });
        it("correctly calculates the sum using key func", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).sum(x => x.foo);
            assert.deepEqual(res, 6);
        }));
    });
    describe("min", () => {
        it("throws for empty lists", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([]).min());
        });
        it("correctly finds min for array of numbers", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([1]).min();
            assert.deepEqual(res, 1);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([1, -1]).min();
            assert.deepEqual(res, -1);
        }));
        it("throws when finding min of non-numbers", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).min());
        });
        it("correctly calculates the min using key func", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).min(x => x.foo);
            assert.deepEqual(res, 1);
        }));
    });
    describe("max", () => {
        it("throws for empty lists", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([]).max());
        });
        it("correctly finds max for array of numbers", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([1]).max();
            assert.deepEqual(res, 1);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([1, -1]).max();
            assert.deepEqual(res, 1);
        }));
        it("throws when finding max of non-numbers", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).max());
        });
        it("correctly calculates the max using key func", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).max(x => x.foo);
            assert.deepEqual(res, 3);
        }));
    });
    describe("average", () => {
        it("throws for empty lists", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([]).average());
        });
        it("correctly finds average for array of numbers", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([1]).average();
            assert.deepEqual(res, 1);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([1, -1]).average();
            assert.deepEqual(res, 0);
        }));
        it("throws when finding average of non-numbers", done => {
            assertRejects(done, asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).average());
        });
        it("correctly calculates the average using key func", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).average(x => x.foo);
            assert.deepEqual(res, 2);
        }));
    });
    describe("aggregate", () => {
        it("throws for empty lists", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield asyncQueryable_1.AsyncQueryableImpl.from([]).aggregate(0, acc => acc + 13);
            assert.deepEqual(res, 0);
        }));
        it("aggregates (+) over array of numbers", () => __awaiter(this, void 0, void 0, function* () {
            let res = yield asyncQueryable_1.AsyncQueryableImpl.from([1]).aggregate(0, (acc, i) => acc + i);
            assert.deepEqual(res, 1);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([1, -1]).aggregate(0, (acc, i) => acc + i);
            assert.deepEqual(res, 0);
            res = yield asyncQueryable_1.AsyncQueryableImpl.from([{ foo: 1 }, { foo: 2 }, { foo: 3 }]).aggregate(0, (acc, o) => acc + o.foo);
            assert.deepEqual(res, 6);
        }));
    });
});
describe("IterablePromise eval operators", () => {
    describe("toArray", () => {
        it("returns empty array for empty enumerable", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([]).toArray();
            assert.deepEqual(xs, []);
        }));
    });
});
describe("IterablePromise iterable interop operators", () => {
    describe("pipe", () => {
        it("allows composition of multiple async iterators", () => __awaiter(this, void 0, void 0, function* () {
            const xs = yield asyncQueryable_1.AsyncQueryableImpl.from([1, 2, 3, 4])
                .pipe(function (source) {
                return __asyncGenerator(this, arguments, function* () {
                    var e_1, _a;
                    try {
                        for (var source_1 = __asyncValues(source), source_1_1; source_1_1 = yield __await(source_1.next()), !source_1_1.done;) {
                            const t = source_1_1.value;
                            if (t > 2) {
                                yield yield __await(t);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield __await(_a.call(source_1));
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                });
            }, function (source) {
                return __asyncGenerator(this, arguments, function* () {
                    var e_2, _a;
                    try {
                        for (var source_2 = __asyncValues(source), source_2_1; source_2_1 = yield __await(source_2.next()), !source_2_1.done;) {
                            const t = source_2_1.value;
                            yield yield __await(t + 2);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (source_2_1 && !source_2_1.done && (_a = source_2.return)) yield __await(_a.call(source_2));
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                });
            })
                .toArray();
            assert.deepEqual(xs, [5, 6]);
        }));
    });
});
