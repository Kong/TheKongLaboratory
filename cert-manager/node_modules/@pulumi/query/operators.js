"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const base_1 = require("./base");
const sources_1 = require("./sources");
//
// Restriction operators.
//
function filter(f) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(zip(source, sources_1.range(0))), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [t, i] = _c.value;
                    if (yield __await(f(t, i))) {
                        yield yield __await(t);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
}
exports.filter = filter;
//
// Projection operators.
//
function flatMap(selector, resultSelector = (t, ti) => ti) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_2, _a, e_3, _b;
            try {
                for (var _c = __asyncValues(zip(source, sources_1.range(0))), _d; _d = yield __await(_c.next()), !_d.done;) {
                    const [t, i] = _d.value;
                    const us = selector(t, i);
                    try {
                        for (var _e = __asyncValues(sources_1.from(us)), _f; _f = yield __await(_e.next()), !_f.done;) {
                            const u = _f.value;
                            yield yield __await(yield __await(resultSelector(t, u)));
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) yield __await(_b.call(_e));
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) yield __await(_a.call(_c));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    };
}
exports.flatMap = flatMap;
function map(f) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_4, _a;
            try {
                for (var _b = __asyncValues(zip(source, sources_1.range(0))), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [t, i] = _c.value;
                    yield yield __await(yield __await(f(t, i)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    };
}
exports.map = map;
//
// Partitioning operators.
//
function skip(n) {
    if (n < 0) {
        throw Error("skip was provided a negative number of elements to skip");
    }
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_5, _a;
            try {
                for (var _b = __asyncValues(zip(source, sources_1.range(1))), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [t, i] = _c.value;
                    if (i > n) {
                        yield yield __await(t);
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    };
}
exports.skip = skip;
function skipWhile(predicate) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_6, _a;
            let stopSkipping = false;
            try {
                for (var _b = __asyncValues(zip(source, sources_1.range(0))), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [t, i] = _c.value;
                    if (stopSkipping === true) {
                        yield yield __await(t);
                    }
                    else if ((yield __await(predicate(t, i))) === false) {
                        stopSkipping = true;
                        yield yield __await(t);
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    };
}
exports.skipWhile = skipWhile;
function take(n) {
    if (n < 0) {
        throw Error("take was provided a negative number of elements to take");
    }
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_7, _a;
            try {
                for (var _b = __asyncValues(zip(source, sources_1.range(0))), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [t, i] = _c.value;
                    if (i >= n) {
                        return yield __await(void 0);
                    }
                    yield yield __await(t);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    };
}
exports.take = take;
function takeWhile(predicate) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_8, _a;
            try {
                for (var _b = __asyncValues(zip(source, sources_1.range(0))), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [t, i] = _c.value;
                    if ((yield __await(predicate(t, i))) === false) {
                        return yield __await(void 0);
                    }
                    yield yield __await(t);
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    };
}
exports.takeWhile = takeWhile;
//
// Join operators.
//
function joinHelper(outer, inner, outerKeySelector, innerKeySelector) {
    return __asyncGenerator(this, arguments, function* joinHelper_1() {
        var e_9, _a, e_10, _b;
        const inners = new Map();
        try {
            for (var inner_1 = __asyncValues(inner), inner_1_1; inner_1_1 = yield __await(inner_1.next()), !inner_1_1.done;) {
                const t = inner_1_1.value;
                const key = yield __await(innerKeySelector(t));
                const val = inners.get(key);
                if (inners.has(key)) {
                    val.push(t);
                }
                else {
                    inners.set(key, [t]);
                }
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (inner_1_1 && !inner_1_1.done && (_a = inner_1.return)) yield __await(_a.call(inner_1));
            }
            finally { if (e_9) throw e_9.error; }
        }
        try {
            for (var outer_1 = __asyncValues(outer), outer_1_1; outer_1_1 = yield __await(outer_1.next()), !outer_1_1.done;) {
                const t = outer_1_1.value;
                const key = yield __await(outerKeySelector(t));
                if (key === undefined) {
                    continue;
                }
                else if (inners.has(key)) {
                    const innerValues = inners.get(key);
                    yield yield __await([t, innerValues]);
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (outer_1_1 && !outer_1_1.done && (_b = outer_1.return)) yield __await(_b.call(outer_1));
            }
            finally { if (e_10) throw e_10.error; }
        }
    });
}
function join(inner, outerKeySelector, innerKeySelector, resultSelector) {
    return function (outer) {
        return __asyncGenerator(this, arguments, function* () {
            var e_11, _a;
            try {
                for (var _b = __asyncValues(joinHelper(outer, inner, outerKeySelector, innerKeySelector)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [o, inners] = _c.value;
                    for (const i of inners) {
                        yield yield __await(yield __await(resultSelector(o, i)));
                    }
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_11) throw e_11.error; }
            }
        });
    };
}
exports.join = join;
function groupJoin(inner, outerKeySelector, innerKeySelector, resultSelector) {
    return function (outer) {
        return __asyncGenerator(this, arguments, function* () {
            var e_12, _a;
            try {
                for (var _b = __asyncValues(joinHelper(outer, inner, outerKeySelector, innerKeySelector)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [o, inners] = _c.value;
                    yield yield __await(yield __await(resultSelector(o, sources_1.from(inners))));
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_12) throw e_12.error; }
            }
        });
    };
}
exports.groupJoin = groupJoin;
//
// Concatenation operators.
//
function concat(iter) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_13, _a, e_14, _b;
            try {
                for (var source_1 = __asyncValues(source), source_1_1; source_1_1 = yield __await(source_1.next()), !source_1_1.done;) {
                    const t = source_1_1.value;
                    yield yield __await(t);
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield __await(_a.call(source_1));
                }
                finally { if (e_13) throw e_13.error; }
            }
            try {
                for (var iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield __await(iter_1.next()), !iter_1_1.done;) {
                    const t = iter_1_1.value;
                    yield yield __await(t);
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (iter_1_1 && !iter_1_1.done && (_b = iter_1.return)) yield __await(_b.call(iter_1));
                }
                finally { if (e_14) throw e_14.error; }
            }
        });
    };
}
exports.concat = concat;
//
// Ordering operators.
//
function orderBy(keySelector) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            //
            // NOTE: This horrible little function is necessary because the default behavior of
            // JavaScript's `Array#sort` is to coerce every element in the array into string, and then
            // sort those strings lexically.
            //
            // This, of course, is completely unacceptable. Approximately 0 users call `.sort` on an
            // array of `Object` with the intention that they be sorted in this manner. The right thing
            // to do is to simply assume this is a user error and throw an exception.
            //
            // If the user actually wants to sort an array of `Object` by their stringified
            // representation, let them pass us a key function that performs this conversion explicitly.
            // There is no particular need for Brendan Eich's problems from 30 years ago to become our
            // users' problems today.
            //
            let lastKey;
            const ts = yield __await(map(function (t) {
                return __awaiter(this, void 0, void 0, function* () {
                    const key = yield keySelector(t);
                    if (lastKey === undefined) {
                        lastKey = key;
                    }
                    else {
                        if (util_1.isNumber(key) && util_1.isString(key)) {
                            throw Error("keySelector must produce a number or a string");
                        }
                        if (typeof lastKey !== typeof key) {
                            throw Error(`keySelector must produce keys all of the same type, but found ` +
                                `${typeof key} and ${typeof lastKey}`);
                        }
                    }
                    return [key, t];
                });
            })(source));
            const keyed = yield __await(toArray()(ts));
            const comparator = ((util_1.isNumber(lastKey)
                ? (a, b) => a - b
                : (a, b) => a.localeCompare(b)));
            const sorted = keyed.sort(([k1], [k2]) => comparator(k1, k2));
            for (const [, t] of sorted) {
                yield yield __await(t);
            }
        });
    };
}
exports.orderBy = orderBy;
function orderByDescending(keySelector) {
    return function (source) {
        return reverse()(orderBy(keySelector)(source));
    };
}
exports.orderByDescending = orderByDescending;
function reverse() {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_15, _a;
            const ts = [];
            try {
                for (var source_2 = __asyncValues(source), source_2_1; source_2_1 = yield __await(source_2.next()), !source_2_1.done;) {
                    const t = source_2_1.value;
                    ts.push(t);
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (source_2_1 && !source_2_1.done && (_a = source_2.return)) yield __await(_a.call(source_2));
                }
                finally { if (e_15) throw e_15.error; }
            }
            for (const t of ts.reverse()) {
                yield yield __await(t);
            }
        });
    };
}
exports.reverse = reverse;
//
// Grouping operators.
//
function groupBy(keySelector, elementSelector) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_16, _a;
            if (elementSelector === undefined) {
                elementSelector = t => t;
            }
            const groups = new Map();
            try {
                for (var source_3 = __asyncValues(source), source_3_1; source_3_1 = yield __await(source_3.next()), !source_3_1.done;) {
                    const t = source_3_1.value;
                    const key = yield __await(keySelector(t));
                    const val = yield __await(elementSelector(t));
                    if (!groups.has(key)) {
                        groups.set(key, [val]);
                    }
                    else {
                        const group = groups.get(key);
                        group.push(val);
                    }
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (source_3_1 && !source_3_1.done && (_a = source_3.return)) yield __await(_a.call(source_3));
                }
                finally { if (e_16) throw e_16.error; }
            }
            for (const [key, group] of groups) {
                yield yield __await(new base_1.GroupedAsyncIterableIteratorImpl(key, sources_1.from(group)));
            }
        });
    };
}
exports.groupBy = groupBy;
//
// Set operators.
//
function distinct() {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_17, _a;
            const dist = new Set();
            try {
                for (var source_4 = __asyncValues(source), source_4_1; source_4_1 = yield __await(source_4.next()), !source_4_1.done;) {
                    const t = source_4_1.value;
                    if (!dist.has(t)) {
                        dist.add(t);
                        yield yield __await(t);
                    }
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (source_4_1 && !source_4_1.done && (_a = source_4.return)) yield __await(_a.call(source_4));
                }
                finally { if (e_17) throw e_17.error; }
            }
        });
    };
}
exports.distinct = distinct;
function union(second) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_18, _a, e_19, _b;
            const dist = new Set();
            try {
                for (var source_5 = __asyncValues(source), source_5_1; source_5_1 = yield __await(source_5.next()), !source_5_1.done;) {
                    const t = source_5_1.value;
                    if (!dist.has(t)) {
                        dist.add(t);
                        yield yield __await(t);
                    }
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (source_5_1 && !source_5_1.done && (_a = source_5.return)) yield __await(_a.call(source_5));
                }
                finally { if (e_18) throw e_18.error; }
            }
            try {
                for (var second_1 = __asyncValues(second), second_1_1; second_1_1 = yield __await(second_1.next()), !second_1_1.done;) {
                    const t = second_1_1.value;
                    if (!dist.has(t)) {
                        dist.add(t);
                        yield yield __await(t);
                    }
                }
            }
            catch (e_19_1) { e_19 = { error: e_19_1 }; }
            finally {
                try {
                    if (second_1_1 && !second_1_1.done && (_b = second_1.return)) yield __await(_b.call(second_1));
                }
                finally { if (e_19) throw e_19.error; }
            }
        });
    };
}
exports.union = union;
function intersect(second) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_20, _a, e_21, _b;
            const dist = new Set();
            try {
                for (var source_6 = __asyncValues(source), source_6_1; source_6_1 = yield __await(source_6.next()), !source_6_1.done;) {
                    const t = source_6_1.value;
                    dist.add(t);
                }
            }
            catch (e_20_1) { e_20 = { error: e_20_1 }; }
            finally {
                try {
                    if (source_6_1 && !source_6_1.done && (_a = source_6.return)) yield __await(_a.call(source_6));
                }
                finally { if (e_20) throw e_20.error; }
            }
            const emitted = new Set();
            try {
                for (var second_2 = __asyncValues(second), second_2_1; second_2_1 = yield __await(second_2.next()), !second_2_1.done;) {
                    const t = second_2_1.value;
                    if (dist.has(t) && !emitted.has(t)) {
                        emitted.add(t);
                        yield yield __await(t);
                    }
                }
            }
            catch (e_21_1) { e_21 = { error: e_21_1 }; }
            finally {
                try {
                    if (second_2_1 && !second_2_1.done && (_b = second_2.return)) yield __await(_b.call(second_2));
                }
                finally { if (e_21) throw e_21.error; }
            }
        });
    };
}
exports.intersect = intersect;
function except(second) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_22, _a, e_23, _b;
            const dist = new Set();
            try {
                for (var source_7 = __asyncValues(source), source_7_1; source_7_1 = yield __await(source_7.next()), !source_7_1.done;) {
                    const t = source_7_1.value;
                    dist.add(t);
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (source_7_1 && !source_7_1.done && (_a = source_7.return)) yield __await(_a.call(source_7));
                }
                finally { if (e_22) throw e_22.error; }
            }
            try {
                for (var second_3 = __asyncValues(second), second_3_1; second_3_1 = yield __await(second_3.next()), !second_3_1.done;) {
                    const t = second_3_1.value;
                    if (dist.has(t)) {
                        dist.delete(t);
                    }
                    else {
                        dist.add(t);
                    }
                }
            }
            catch (e_23_1) { e_23 = { error: e_23_1 }; }
            finally {
                try {
                    if (second_3_1 && !second_3_1.done && (_b = second_3.return)) yield __await(_b.call(second_3));
                }
                finally { if (e_23) throw e_23.error; }
            }
            for (const t of dist) {
                yield yield __await(t);
            }
        });
    };
}
exports.except = except;
//
// Conversion operators.
//
function toArray() {
    return function (source) {
        var source_8, source_8_1;
        var e_24, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const ret = [];
            try {
                for (source_8 = __asyncValues(source); source_8_1 = yield source_8.next(), !source_8_1.done;) {
                    const t = source_8_1.value;
                    ret.push(t);
                }
            }
            catch (e_24_1) { e_24 = { error: e_24_1 }; }
            finally {
                try {
                    if (source_8_1 && !source_8_1.done && (_a = source_8.return)) yield _a.call(source_8);
                }
                finally { if (e_24) throw e_24.error; }
            }
            return ret;
        });
    };
}
exports.toArray = toArray;
function toMap(keySelector, elementSelector) {
    return function (source) {
        var source_9, source_9_1;
        var e_25, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (elementSelector === undefined) {
                elementSelector = x => x;
            }
            const ret = new Map();
            try {
                for (source_9 = __asyncValues(source); source_9_1 = yield source_9.next(), !source_9_1.done;) {
                    const t = source_9_1.value;
                    const key = yield keySelector(t);
                    if (key === undefined) {
                        throw Error("key selector can't produce a null value");
                    }
                    const val = yield elementSelector(t);
                    ret.set(key, val);
                }
            }
            catch (e_25_1) { e_25 = { error: e_25_1 }; }
            finally {
                try {
                    if (source_9_1 && !source_9_1.done && (_a = source_9.return)) yield _a.call(source_9);
                }
                finally { if (e_25) throw e_25.error; }
            }
            return ret;
        });
    };
}
exports.toMap = toMap;
function ofType(typeGuard) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_26, _a;
            try {
                for (var source_10 = __asyncValues(source), source_10_1; source_10_1 = yield __await(source_10.next()), !source_10_1.done;) {
                    const t = source_10_1.value;
                    if (typeGuard(t)) {
                        yield yield __await(t);
                    }
                }
            }
            catch (e_26_1) { e_26 = { error: e_26_1 }; }
            finally {
                try {
                    if (source_10_1 && !source_10_1.done && (_a = source_10.return)) yield __await(_a.call(source_10));
                }
                finally { if (e_26) throw e_26.error; }
            }
        });
    };
}
exports.ofType = ofType;
//
// Element operators.
//
function first(predicate) {
    return function (source) {
        var source_11, source_11_1;
        var e_27, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (predicate === undefined) {
                predicate = t => true;
            }
            try {
                for (source_11 = __asyncValues(source); source_11_1 = yield source_11.next(), !source_11_1.done;) {
                    const t = source_11_1.value;
                    if ((yield predicate(t)) === true) {
                        return t;
                    }
                }
            }
            catch (e_27_1) { e_27 = { error: e_27_1 }; }
            finally {
                try {
                    if (source_11_1 && !source_11_1.done && (_a = source_11.return)) yield _a.call(source_11);
                }
                finally { if (e_27) throw e_27.error; }
            }
            return Promise.reject("first could not find any elements that match predicate");
        });
    };
}
exports.first = first;
function firstOrDefault(defaultValue, predicate) {
    return function (source) {
        var source_12, source_12_1;
        var e_28, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (predicate === undefined) {
                predicate = t => true;
            }
            try {
                for (source_12 = __asyncValues(source); source_12_1 = yield source_12.next(), !source_12_1.done;) {
                    const t = source_12_1.value;
                    if ((yield predicate(t)) === true) {
                        return t;
                    }
                }
            }
            catch (e_28_1) { e_28 = { error: e_28_1 }; }
            finally {
                try {
                    if (source_12_1 && !source_12_1.done && (_a = source_12.return)) yield _a.call(source_12);
                }
                finally { if (e_28) throw e_28.error; }
            }
            return defaultValue;
        });
    };
}
exports.firstOrDefault = firstOrDefault;
function last(predicate) {
    return function (source) {
        var source_13, source_13_1;
        var e_29, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (predicate === undefined) {
                predicate = t => true;
            }
            let curr;
            try {
                for (source_13 = __asyncValues(source); source_13_1 = yield source_13.next(), !source_13_1.done;) {
                    const t = source_13_1.value;
                    if ((yield predicate(t)) === true) {
                        curr = t;
                    }
                }
            }
            catch (e_29_1) { e_29 = { error: e_29_1 }; }
            finally {
                try {
                    if (source_13_1 && !source_13_1.done && (_a = source_13.return)) yield _a.call(source_13);
                }
                finally { if (e_29) throw e_29.error; }
            }
            if (curr === undefined) {
                return Promise.reject("last could not find any elements that match predicate");
            }
            else {
                return curr;
            }
        });
    };
}
exports.last = last;
function lastOrDefault(defaultValue, predicate) {
    return function (source) {
        var source_14, source_14_1;
        var e_30, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (predicate === undefined) {
                predicate = t => true;
            }
            let curr;
            try {
                for (source_14 = __asyncValues(source); source_14_1 = yield source_14.next(), !source_14_1.done;) {
                    const t = source_14_1.value;
                    if ((yield predicate(t)) === true) {
                        curr = t;
                    }
                }
            }
            catch (e_30_1) { e_30 = { error: e_30_1 }; }
            finally {
                try {
                    if (source_14_1 && !source_14_1.done && (_a = source_14.return)) yield _a.call(source_14);
                }
                finally { if (e_30) throw e_30.error; }
            }
            if (curr === undefined) {
                return defaultValue;
            }
            else {
                return curr;
            }
        });
    };
}
exports.lastOrDefault = lastOrDefault;
function single(predicate) {
    return function (source) {
        return __awaiter(this, void 0, void 0, function* () {
            if (predicate === undefined) {
                predicate = t => true;
            }
            const seq = yield toArray()(filter(predicate)(source));
            if (seq.length === 0) {
                throw Error("single did not find any elements matching the predicate");
            }
            else if (seq.length > 1) {
                throw Error("single found multiple elements matching the predicate");
            }
            return seq[0];
        });
    };
}
exports.single = single;
function singleOrDefault(defaultValue, predicate) {
    return function (source) {
        return __awaiter(this, void 0, void 0, function* () {
            if (predicate === undefined) {
                predicate = t => true;
            }
            const seq = yield toArray()(filter(predicate)(source));
            if (seq.length === 0) {
                return defaultValue;
            }
            else if (seq.length > 1) {
                throw Error("single found multiple elements matching the predicate");
            }
            else {
                return seq[0];
            }
        });
    };
}
exports.singleOrDefault = singleOrDefault;
function elementAt(index) {
    return function (source) {
        var e_31, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // TODO: Maybe support `Array` here if we ever support sync iterables. This would allow us
                // to access that index directly.
                for (var _b = __asyncValues(zip(source, sources_1.range(0))), _c; _c = yield _b.next(), !_c.done;) {
                    const [t, i] = _c.value;
                    if (i === index) {
                        return t;
                    }
                }
            }
            catch (e_31_1) { e_31 = { error: e_31_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_31) throw e_31.error; }
            }
            throw Error(`elementAt tried to find item at index ${index}, but sequence had fewer elements`);
        });
    };
}
exports.elementAt = elementAt;
function elementAtOrDefault(defaultValue, index) {
    return function (source) {
        var e_32, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // TODO: Maybe support `Array` here if we ever support sync iterables. This would allow us
                // to access that index directly.
                for (var _b = __asyncValues(zip(source, sources_1.range(0))), _c; _c = yield _b.next(), !_c.done;) {
                    const [t, i] = _c.value;
                    if (i === index) {
                        return t;
                    }
                }
            }
            catch (e_32_1) { e_32 = { error: e_32_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_32) throw e_32.error; }
            }
            return defaultValue;
        });
    };
}
exports.elementAtOrDefault = elementAtOrDefault;
function defaultIfEmpty(defaultValue) {
    return function (source) {
        return __asyncGenerator(this, arguments, function* () {
            var e_33, _a;
            let sequenceEmpty = true;
            try {
                for (var source_15 = __asyncValues(source), source_15_1; source_15_1 = yield __await(source_15.next()), !source_15_1.done;) {
                    const t = source_15_1.value;
                    sequenceEmpty = false;
                    yield yield __await(t);
                }
            }
            catch (e_33_1) { e_33 = { error: e_33_1 }; }
            finally {
                try {
                    if (source_15_1 && !source_15_1.done && (_a = source_15.return)) yield __await(_a.call(source_15));
                }
                finally { if (e_33) throw e_33.error; }
            }
            if (sequenceEmpty) {
                yield yield __await(defaultValue);
            }
        });
    };
}
exports.defaultIfEmpty = defaultIfEmpty;
//
// Quantifiers.
//
function any(predicate) {
    return function (source) {
        var source_16, source_16_1;
        var e_34, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (predicate === undefined) {
                predicate = t => true;
            }
            try {
                for (source_16 = __asyncValues(source); source_16_1 = yield source_16.next(), !source_16_1.done;) {
                    const t = source_16_1.value;
                    if ((yield predicate(t)) === true) {
                        return true;
                    }
                }
            }
            catch (e_34_1) { e_34 = { error: e_34_1 }; }
            finally {
                try {
                    if (source_16_1 && !source_16_1.done && (_a = source_16.return)) yield _a.call(source_16);
                }
                finally { if (e_34) throw e_34.error; }
            }
            return false;
        });
    };
}
exports.any = any;
function all(predicate) {
    return function (source) {
        var source_17, source_17_1;
        var e_35, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (source_17 = __asyncValues(source); source_17_1 = yield source_17.next(), !source_17_1.done;) {
                    const t = source_17_1.value;
                    if ((yield predicate(t)) === false) {
                        return false;
                    }
                }
            }
            catch (e_35_1) { e_35 = { error: e_35_1 }; }
            finally {
                try {
                    if (source_17_1 && !source_17_1.done && (_a = source_17.return)) yield _a.call(source_17);
                }
                finally { if (e_35) throw e_35.error; }
            }
            return true;
        });
    };
}
exports.all = all;
function contains(value) {
    return function (source) {
        var source_18, source_18_1;
        var e_36, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const dist = new Set([value]);
            try {
                for (source_18 = __asyncValues(source); source_18_1 = yield source_18.next(), !source_18_1.done;) {
                    const t = source_18_1.value;
                    if (dist.has(t)) {
                        return true;
                    }
                }
            }
            catch (e_36_1) { e_36 = { error: e_36_1 }; }
            finally {
                try {
                    if (source_18_1 && !source_18_1.done && (_a = source_18.return)) yield _a.call(source_18);
                }
                finally { if (e_36) throw e_36.error; }
            }
            return false;
        });
    };
}
exports.contains = contains;
//
// Aggregate operators.
//
function count(predicate) {
    return function (source) {
        var source_19, source_19_1;
        var e_37, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (predicate === undefined) {
                predicate = t => true;
            }
            let n = 0;
            try {
                for (source_19 = __asyncValues(source); source_19_1 = yield source_19.next(), !source_19_1.done;) {
                    const t = source_19_1.value;
                    if ((yield predicate(t)) === true) {
                        n++;
                    }
                }
            }
            catch (e_37_1) { e_37 = { error: e_37_1 }; }
            finally {
                try {
                    if (source_19_1 && !source_19_1.done && (_a = source_19.return)) yield _a.call(source_19);
                }
                finally { if (e_37) throw e_37.error; }
            }
            return n;
        });
    };
}
exports.count = count;
function sum(selector) {
    return function (source) {
        var source_20, source_20_1;
        var e_38, _a;
        return __awaiter(this, void 0, void 0, function* () {
            // If selector is undefined, the source should emit `number`.
            if (selector === undefined) {
                selector = t => t;
            }
            let total = 0;
            try {
                for (source_20 = __asyncValues(source); source_20_1 = yield source_20.next(), !source_20_1.done;) {
                    const t = source_20_1.value;
                    const toSum = yield selector(t);
                    if (!util_1.isNumber(toSum)) {
                        throw Error("Can't sum things that aren't numbers");
                    }
                    total += toSum;
                }
            }
            catch (e_38_1) { e_38 = { error: e_38_1 }; }
            finally {
                try {
                    if (source_20_1 && !source_20_1.done && (_a = source_20.return)) yield _a.call(source_20);
                }
                finally { if (e_38) throw e_38.error; }
            }
            return total;
        });
    };
}
exports.sum = sum;
function min(selector) {
    return function (source) {
        var source_21, source_21_1;
        var e_39, _a;
        return __awaiter(this, void 0, void 0, function* () {
            // If selector is undefined, the source should emit `number`.
            if (selector === undefined) {
                selector = t => t;
            }
            let minimum = undefined;
            try {
                for (source_21 = __asyncValues(source); source_21_1 = yield source_21.next(), !source_21_1.done;) {
                    const t = source_21_1.value;
                    const curr = yield selector(t);
                    if (minimum === undefined) {
                        minimum = curr;
                    }
                    if (!util_1.isNumber(curr)) {
                        throw Error("min can't find the minimum of things that aren't numbers");
                    }
                    if (minimum > curr) {
                        minimum = curr;
                    }
                }
            }
            catch (e_39_1) { e_39 = { error: e_39_1 }; }
            finally {
                try {
                    if (source_21_1 && !source_21_1.done && (_a = source_21.return)) yield _a.call(source_21);
                }
                finally { if (e_39) throw e_39.error; }
            }
            if (minimum === undefined) {
                throw Error("min can't be called on an empty sequence");
            }
            return minimum;
        });
    };
}
exports.min = min;
function max(selector) {
    return function (source) {
        var source_22, source_22_1;
        var e_40, _a;
        return __awaiter(this, void 0, void 0, function* () {
            // If selector is undefined, the source should emit `number`.
            if (selector === undefined) {
                selector = t => t;
            }
            let maximum = undefined;
            try {
                for (source_22 = __asyncValues(source); source_22_1 = yield source_22.next(), !source_22_1.done;) {
                    const t = source_22_1.value;
                    const curr = yield selector(t);
                    if (maximum === undefined) {
                        maximum = curr;
                    }
                    if (!util_1.isNumber(curr)) {
                        throw Error("max can't find the maximum of things that aren't numbers");
                    }
                    if (maximum < curr) {
                        maximum = curr;
                    }
                }
            }
            catch (e_40_1) { e_40 = { error: e_40_1 }; }
            finally {
                try {
                    if (source_22_1 && !source_22_1.done && (_a = source_22.return)) yield _a.call(source_22);
                }
                finally { if (e_40) throw e_40.error; }
            }
            if (maximum === undefined) {
                throw Error("max can't be called on an empty sequence");
            }
            return maximum;
        });
    };
}
exports.max = max;
function average(selector) {
    return function (source) {
        var source_23, source_23_1;
        var e_41, _a;
        return __awaiter(this, void 0, void 0, function* () {
            // If selector is undefined, the source should emit `number`.
            if (selector === undefined) {
                selector = t => t;
            }
            let total = 0;
            let cnt = 0;
            try {
                for (source_23 = __asyncValues(source); source_23_1 = yield source_23.next(), !source_23_1.done;) {
                    const t = source_23_1.value;
                    const toSum = yield selector(t);
                    if (!util_1.isNumber(toSum)) {
                        throw Error("Can't sum things that aren't numbers");
                    }
                    total += toSum;
                    cnt++;
                }
            }
            catch (e_41_1) { e_41 = { error: e_41_1 }; }
            finally {
                try {
                    if (source_23_1 && !source_23_1.done && (_a = source_23.return)) yield _a.call(source_23);
                }
                finally { if (e_41) throw e_41.error; }
            }
            if (cnt === 0) {
                return Promise.reject("Can't compute average of empty sequence");
            }
            return total / cnt;
        });
    };
}
exports.average = average;
function aggregate(seed, func) {
    return function (source) {
        var source_24, source_24_1;
        var e_42, _a;
        return __awaiter(this, void 0, void 0, function* () {
            let acc = seed;
            try {
                for (source_24 = __asyncValues(source); source_24_1 = yield source_24.next(), !source_24_1.done;) {
                    const t = source_24_1.value;
                    acc = yield func(acc, t);
                }
            }
            catch (e_42_1) { e_42 = { error: e_42_1 }; }
            finally {
                try {
                    if (source_24_1 && !source_24_1.done && (_a = source_24.return)) yield _a.call(source_24);
                }
                finally { if (e_42) throw e_42.error; }
            }
            return acc;
        });
    };
}
exports.aggregate = aggregate;
//
// Misc.
//
function zip(source1, source2, resultSelector = (t1, t2) => [t1, t2]) {
    return __asyncGenerator(this, arguments, function* zip_1() {
        while (true) {
            const result1 = yield __await(source1.next());
            const result2 = yield __await(source2.next());
            if (result1.done || result2.done) {
                return yield __await(void 0);
            }
            else {
                yield yield __await(yield __await(resultSelector(result1.value, result2.value)));
            }
        }
    });
}
exports.zip = zip;
