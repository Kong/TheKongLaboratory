"use strict";
// Copyright 2016-2021, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const yaml = require("js-yaml");
const os = require("os");
const semver = require("semver");
const upath = require("upath");
const cmd_1 = require("./cmd");
const minimumVersion_1 = require("./minimumVersion");
const stack_1 = require("./stack");
const stackSettings_1 = require("./stackSettings");
const SKIP_VERSION_CHECK_VAR = "PULUMI_AUTOMATION_API_SKIP_VERSION_CHECK";
/**
 * LocalWorkspace is a default implementation of the Workspace interface.
 * A Workspace is the execution context containing a single Pulumi project, a program,
 * and multiple stacks. Workspaces are used to manage the execution environment,
 * providing various utilities such as plugin installation, environment configuration
 * ($PULUMI_HOME), and creation, deletion, and listing of Stacks.
 * LocalWorkspace relies on Pulumi.yaml and Pulumi.<stack>.yaml as the intermediate format
 * for Project and Stack settings. Modifying ProjectSettings will
 * alter the Workspace Pulumi.yaml file, and setting config on a Stack will modify the Pulumi.<stack>.yaml file.
 * This is identical to the behavior of Pulumi CLI driven workspaces.
 *
 * @alpha
 */
class LocalWorkspace {
    constructor(opts) {
        let dir = "";
        let envs = {};
        if (opts) {
            const { workDir, pulumiHome, program, envVars, secretsProvider } = opts;
            if (workDir) {
                dir = workDir;
            }
            this.pulumiHome = pulumiHome;
            this.program = program;
            this.secretsProvider = secretsProvider;
            envs = Object.assign({}, envVars);
        }
        if (!dir) {
            dir = fs.mkdtempSync(upath.joinSafe(os.tmpdir(), "automation-"));
        }
        this.workDir = dir;
        this.envVars = envs;
        const readinessPromises = [this.getPulumiVersion(minimumVersion_1.minimumVersion)];
        if (opts && opts.projectSettings) {
            readinessPromises.push(this.saveProjectSettings(opts.projectSettings));
        }
        if (opts && opts.stackSettings) {
            for (const [name, value] of Object.entries(opts.stackSettings)) {
                readinessPromises.push(this.saveStackSettings(name, value));
            }
        }
        this.ready = Promise.all(readinessPromises);
    }
    /**
     * The version of the underlying Pulumi CLI/Engine.
     *
     * @returns A string representation of the version, if available. `null` otherwise.
     */
    get pulumiVersion() {
        if (this._pulumiVersion === undefined) {
            throw new Error(`Failed to get Pulumi version`);
        }
        return this._pulumiVersion.toString();
    }
    /**
     * Creates a workspace using the specified options. Used for maximal control and customization
     * of the underlying environment before any stacks are created or selected.
     *
     * @param opts Options used to configure the Workspace
     */
    static create(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const ws = new LocalWorkspace(opts);
            yield ws.ready;
            return ws;
        });
    }
    static createStack(args, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isInlineProgramArgs(args)) {
                return yield this.inlineSourceStackHelper(args, stack_1.Stack.create, opts);
            }
            else if (isLocalProgramArgs(args)) {
                return yield this.localSourceStackHelper(args, stack_1.Stack.create, opts);
            }
            throw new Error(`unexpected args: ${args}`);
        });
    }
    static selectStack(args, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isInlineProgramArgs(args)) {
                return yield this.inlineSourceStackHelper(args, stack_1.Stack.select, opts);
            }
            else if (isLocalProgramArgs(args)) {
                return yield this.localSourceStackHelper(args, stack_1.Stack.select, opts);
            }
            throw new Error(`unexpected args: ${args}`);
        });
    }
    static createOrSelectStack(args, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isInlineProgramArgs(args)) {
                return yield this.inlineSourceStackHelper(args, stack_1.Stack.createOrSelect, opts);
            }
            else if (isLocalProgramArgs(args)) {
                return yield this.localSourceStackHelper(args, stack_1.Stack.createOrSelect, opts);
            }
            throw new Error(`unexpected args: ${args}`);
        });
    }
    static localSourceStackHelper(args, initFn, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let wsOpts = { workDir: args.workDir };
            if (opts) {
                wsOpts = Object.assign(Object.assign({}, opts), { workDir: args.workDir });
            }
            const ws = new LocalWorkspace(wsOpts);
            yield ws.ready;
            return yield initFn(args.stackName, ws);
        });
    }
    static inlineSourceStackHelper(args, initFn, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let wsOpts = { program: args.program };
            if (opts) {
                wsOpts = Object.assign(Object.assign({}, opts), { program: args.program });
            }
            if (!wsOpts.projectSettings) {
                if (!!wsOpts.workDir) {
                    try {
                        // Try to load the project settings.
                        loadProjectSettings(wsOpts.workDir);
                    }
                    catch (e) {
                        // If it failed to find the project settings file, set a default project.
                        if (e.toString().includes("failed to find project settings")) {
                            wsOpts.projectSettings = defaultProject(args.projectName);
                        }
                        else {
                            throw e;
                        }
                    }
                }
                else {
                    wsOpts.projectSettings = defaultProject(args.projectName);
                }
            }
            const ws = new LocalWorkspace(wsOpts);
            yield ws.ready;
            return yield initFn(args.stackName, ws);
        });
    }
    /**
     * Returns the settings object for the current project if any
     * LocalWorkspace reads settings from the Pulumi.yaml in the workspace.
     * A workspace can contain only a single project at a time.
     */
    projectSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            return loadProjectSettings(this.workDir);
        });
    }
    /**
     * Overwrites the settings object in the current project.
     * There can only be a single project per workspace. Fails if new project name does not match old.
     * LocalWorkspace writes this value to a Pulumi.yaml file in Workspace.WorkDir().
     *
     * @param settings The settings object to save to the Workspace.
     */
    saveProjectSettings(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            let foundExt = ".yaml";
            for (const ext of settingsExtensions) {
                const testPath = upath.joinSafe(this.workDir, `Pulumi${ext}`);
                if (fs.existsSync(testPath)) {
                    foundExt = ext;
                    break;
                }
            }
            const path = upath.joinSafe(this.workDir, `Pulumi${foundExt}`);
            let contents;
            if (foundExt === ".json") {
                contents = JSON.stringify(settings, null, 4);
            }
            else {
                contents = yaml.safeDump(settings, { skipInvalid: true });
            }
            return fs.writeFileSync(path, contents);
        });
    }
    /**
     * Returns the settings object for the stack matching the specified stack name if any.
     * LocalWorkspace reads this from a Pulumi.<stack>.yaml file in Workspace.WorkDir().
     *
     * @param stackName The stack to retrieve settings from.
     */
    stackSettings(stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            const stackSettingsName = getStackSettingsName(stackName);
            for (const ext of settingsExtensions) {
                const isJSON = ext === ".json";
                const path = upath.joinSafe(this.workDir, `Pulumi.${stackSettingsName}${ext}`);
                if (!fs.existsSync(path)) {
                    continue;
                }
                const contents = fs.readFileSync(path).toString();
                let stackSettings;
                if (isJSON) {
                    stackSettings = JSON.parse(contents);
                }
                stackSettings = yaml.safeLoad(contents);
                // Transform the serialized representation back to what we expect.
                for (const key of stackSettings_1.stackSettingsSerDeKeys) {
                    if (stackSettings.hasOwnProperty(key[0])) {
                        stackSettings[key[1]] = stackSettings[key[0]];
                        delete stackSettings[key[0]];
                    }
                }
                return stackSettings;
            }
            throw new Error(`failed to find stack settings file in workdir: ${this.workDir}`);
        });
    }
    /**
     * Overwrites the settings object for the stack matching the specified stack name.
     * LocalWorkspace writes this value to a Pulumi.<stack>.yaml file in Workspace.WorkDir()
     *
     * @param stackName The stack to operate on.
     * @param settings The settings object to save.
     */
    saveStackSettings(stackName, settings) {
        return __awaiter(this, void 0, void 0, function* () {
            const stackSettingsName = getStackSettingsName(stackName);
            let foundExt = ".yaml";
            for (const ext of settingsExtensions) {
                const testPath = upath.joinSafe(this.workDir, `Pulumi.${stackSettingsName}${ext}`);
                if (fs.existsSync(testPath)) {
                    foundExt = ext;
                    break;
                }
            }
            const path = upath.joinSafe(this.workDir, `Pulumi.${stackSettingsName}${foundExt}`);
            const serializeSettings = settings;
            let contents;
            // Transform the keys to the serialized representation that we expect.
            for (const key of stackSettings_1.stackSettingsSerDeKeys) {
                if (serializeSettings.hasOwnProperty(key[1])) {
                    serializeSettings[key[0]] = serializeSettings[key[1]];
                    delete serializeSettings[key[1]];
                }
            }
            if (foundExt === ".json") {
                contents = JSON.stringify(serializeSettings, null, 4);
            }
            else {
                contents = yaml.safeDump(serializeSettings, { skipInvalid: true });
            }
            return fs.writeFileSync(path, contents);
        });
    }
    /**
     * Creates and sets a new stack with the stack name, failing if one already exists.
     *
     * @param stackName The stack to create.
     */
    createStack(stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["stack", "init", stackName];
            if (this.secretsProvider) {
                args.push("--secrets-provider", this.secretsProvider);
            }
            yield this.runPulumiCmd(args);
        });
    }
    /**
     * Selects and sets an existing stack matching the stack name, failing if none exists.
     *
     * @param stackName The stack to select.
     */
    selectStack(stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runPulumiCmd(["stack", "select", stackName]);
        });
    }
    /**
     * Deletes the stack and all associated configuration and history.
     *
     * @param stackName The stack to remove
     */
    removeStack(stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runPulumiCmd(["stack", "rm", "--yes", stackName]);
        });
    }
    /**
     * Returns the value associated with the specified stack name and key,
     * scoped to the current workspace. LocalWorkspace reads this config from the matching Pulumi.stack.yaml file.
     *
     * @param stackName The stack to read config from
     * @param key The key to use for the config lookup
     */
    getConfig(stackName, key) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.runPulumiCmd(["config", "get", key, "--json", "--stack", stackName]);
            return JSON.parse(result.stdout);
        });
    }
    /**
     * Returns the config map for the specified stack name, scoped to the current workspace.
     * LocalWorkspace reads this config from the matching Pulumi.stack.yaml file.
     *
     * @param stackName The stack to read config from
     */
    getAllConfig(stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.runPulumiCmd(["config", "--show-secrets", "--json", "--stack", stackName]);
            return JSON.parse(result.stdout);
        });
    }
    /**
     * Sets the specified key-value pair on the provided stack name.
     * LocalWorkspace writes this value to the matching Pulumi.<stack>.yaml file in Workspace.WorkDir().
     *
     * @param stackName The stack to operate on
     * @param key The config key to set
     * @param value The value to set
     */
    setConfig(stackName, key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const secretArg = value.secret ? "--secret" : "--plaintext";
            yield this.runPulumiCmd(["config", "set", key, "--stack", stackName, secretArg, "--non-interactive", "--", value.value]);
        });
    }
    /**
     * Sets all values in the provided config map for the specified stack name.
     * LocalWorkspace writes the config to the matching Pulumi.<stack>.yaml file in Workspace.WorkDir().
     *
     * @param stackName The stack to operate on
     * @param config The `ConfigMap` to upsert against the existing config.
     */
    setAllConfig(stackName, config) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = ["config", "set-all", "--stack", stackName];
            for (const [key, value] of Object.entries(config)) {
                const secretArg = value.secret ? "--secret" : "--plaintext";
                args = [...args, secretArg, `${key}=${value.value}`];
            }
            yield this.runPulumiCmd(args);
        });
    }
    /**
     * Removes the specified key-value pair on the provided stack name.
     * It will remove any matching values in the Pulumi.<stack>.yaml file in Workspace.WorkDir().
     *
     * @param stackName The stack to operate on
     * @param key The config key to remove
     */
    removeConfig(stackName, key) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runPulumiCmd(["config", "rm", key, "--stack", stackName]);
        });
    }
    /**
     *
     * Removes all values in the provided key list for the specified stack name
     * It will remove any matching values in the Pulumi.<stack>.yaml file in Workspace.WorkDir().
     *
     * @param stackName The stack to operate on
     * @param keys The list of keys to remove from the underlying config
     */
    removeAllConfig(stackName, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runPulumiCmd(["config", "rm-all", "--stack", stackName, ...keys]);
        });
    }
    /**
     * Gets and sets the config map used with the last update for Stack matching stack name.
     * It will overwrite all configuration in the Pulumi.<stack>.yaml file in Workspace.WorkDir().
     *
     * @param stackName The stack to refresh
     */
    refreshConfig(stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runPulumiCmd(["config", "refresh", "--force", "--stack", stackName]);
            return this.getAllConfig(stackName);
        });
    }
    /**
     * Returns the currently authenticated user.
     */
    whoAmI() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.runPulumiCmd(["whoami"]);
            return { user: result.stdout.trim() };
        });
    }
    /**
     * Returns a summary of the currently selected stack, if any.
     */
    stack() {
        return __awaiter(this, void 0, void 0, function* () {
            const stacks = yield this.listStacks();
            for (const stack of stacks) {
                if (stack.current) {
                    return stack;
                }
            }
            return undefined;
        });
    }
    /**
     * Returns all Stacks created under the current Project.
     * This queries underlying backend and may return stacks not present in the Workspace (as Pulumi.<stack>.yaml files).
     */
    listStacks() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.runPulumiCmd(["stack", "ls", "--json"]);
            return JSON.parse(result.stdout);
        });
    }
    /**
     * Installs a plugin in the Workspace, for example to use cloud providers like AWS or GCP.
     *
     * @param name the name of the plugin.
     * @param version the version of the plugin e.g. "v1.0.0".
     * @param kind the kind of plugin, defaults to "resource"
     */
    installPlugin(name, version, kind = "resource") {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runPulumiCmd(["plugin", "install", kind, name, version]);
        });
    }
    /**
     * Removes a plugin from the Workspace matching the specified name and version.
     *
     * @param name the optional name of the plugin.
     * @param versionRange optional semver range to check when removing plugins matching the given name
     *  e.g. "1.0.0", ">1.0.0".
     * @param kind he kind of plugin, defaults to "resource".
     */
    removePlugin(name, versionRange, kind = "resource") {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["plugin", "rm", kind];
            if (name) {
                args.push(name);
            }
            if (versionRange) {
                args.push(versionRange);
            }
            args.push("--yes");
            yield this.runPulumiCmd(args);
        });
    }
    /**
     * Returns a list of all plugins installed in the Workspace.
     */
    listPlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.runPulumiCmd(["plugin", "ls", "--json"]);
            return JSON.parse(result.stdout, (key, value) => {
                if (key === "installTime" || key === "lastUsedTime") {
                    return new Date(value);
                }
                return value;
            });
        });
    }
    /**
     * exportStack exports the deployment state of the stack.
     * This can be combined with Workspace.importStack to edit a stack's state (such as recovery from failed deployments).
     *
     * @param stackName the name of the stack.
     */
    exportStack(stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.runPulumiCmd(["stack", "export", "--show-secrets", "--stack", stackName]);
            return JSON.parse(result.stdout);
        });
    }
    /**
     * importStack imports the specified deployment state into a pre-existing stack.
     * This can be combined with Workspace.exportStack to edit a stack's state (such as recovery from failed deployments).
     *
     * @param stackName the name of the stack.
     * @param state the stack state to import.
     */
    importStack(stackName, state) {
        return __awaiter(this, void 0, void 0, function* () {
            const randomSuffix = Math.floor(100000 + Math.random() * 900000);
            const filepath = upath.joinSafe(os.tmpdir(), `automation-${randomSuffix}`);
            const contents = JSON.stringify(state, null, 4);
            fs.writeFileSync(filepath, contents);
            yield this.runPulumiCmd(["stack", "import", "--file", filepath, "--stack", stackName]);
            fs.unlinkSync(filepath);
        });
    }
    /**
     * Gets the current set of Stack outputs from the last Stack.up().
     * @param stackName the name of the stack.
     */
    stackOutputs(stackName) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: do this in parallel after this is fixed https://github.com/pulumi/pulumi/issues/6050
            const maskedResult = yield this.runPulumiCmd(["stack", "output", "--json", "--stack", stackName]);
            const plaintextResult = yield this.runPulumiCmd(["stack", "output", "--json", "--show-secrets", "--stack", stackName]);
            const maskedOuts = JSON.parse(maskedResult.stdout);
            const plaintextOuts = JSON.parse(plaintextResult.stdout);
            const outputs = {};
            for (const [key, value] of Object.entries(plaintextOuts)) {
                const secret = maskedOuts[key] === "[secret]";
                outputs[key] = { value, secret };
            }
            return outputs;
        });
    }
    /**
     * serializeArgsForOp is hook to provide additional args to every CLI commands before they are executed.
     * Provided with stack name,
     * returns a list of args to append to an invoked command ["--config=...", ]
     * LocalWorkspace does not utilize this extensibility point.
     */
    serializeArgsForOp(_) {
        return __awaiter(this, void 0, void 0, function* () {
            // LocalWorkspace does not utilize this extensibility point.
            return [];
        });
    }
    /**
     * postCommandCallback is a hook executed after every command. Called with the stack name.
     * An extensibility point to perform workspace cleanup (CLI operations may create/modify a Pulumi.stack.yaml)
     * LocalWorkspace does not utilize this extensibility point.
     */
    postCommandCallback(_) {
        return __awaiter(this, void 0, void 0, function* () {
            // LocalWorkspace does not utilize this extensibility point.
            return;
        });
    }
    getPulumiVersion(minVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.runPulumiCmd(["version"]);
            const optOut = !!this.envVars[SKIP_VERSION_CHECK_VAR] || !!process.env[SKIP_VERSION_CHECK_VAR];
            const version = parseAndValidatePulumiVersion(minVersion, result.stdout.trim(), optOut);
            if (version != null) {
                this._pulumiVersion = version;
            }
        });
    }
    runPulumiCmd(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let envs = {};
            if (this.pulumiHome) {
                envs["PULUMI_HOME"] = this.pulumiHome;
            }
            envs = Object.assign(Object.assign({}, envs), this.envVars);
            return cmd_1.runPulumiCmd(args, this.workDir, envs);
        });
    }
}
exports.LocalWorkspace = LocalWorkspace;
/**
 * Returns true if the provided `args` object satisfies the `LocalProgramArgs` interface.
 *
 * @param args The args object to evaluate
 */
function isLocalProgramArgs(args) {
    return args.workDir !== undefined;
}
/**
 * Returns true if the provided `args` object satisfies the `InlineProgramArgs` interface.
 *
 * @param args The args object to evaluate
 */
function isInlineProgramArgs(args) {
    return args.projectName !== undefined &&
        args.program !== undefined;
}
const settingsExtensions = [".yaml", ".yml", ".json"];
function getStackSettingsName(name) {
    const parts = name.split("/");
    if (parts.length < 1) {
        return name;
    }
    return parts[parts.length - 1];
}
function defaultProject(projectName) {
    const settings = { name: projectName, runtime: "nodejs", main: process.cwd() };
    return settings;
}
function loadProjectSettings(workDir) {
    for (const ext of settingsExtensions) {
        const isJSON = ext === ".json";
        const path = upath.joinSafe(workDir, `Pulumi${ext}`);
        if (!fs.existsSync(path)) {
            continue;
        }
        const contents = fs.readFileSync(path).toString();
        if (isJSON) {
            return JSON.parse(contents);
        }
        return yaml.safeLoad(contents);
    }
    throw new Error(`failed to find project settings file in workdir: ${workDir}`);
}
/**
 * @internal
 * Throws an error if the Pulumi CLI version is not valid.
 *
 * @param minVersion The minimum acceptable version of the Pulumi CLI.
 * @param currentVersion The currently known version. `null` indicates that the current version is unknown.
 * @paramoptOut If the user has opted out of the version check.
 */
function parseAndValidatePulumiVersion(minVersion, currentVersion, optOut) {
    const version = semver.parse(currentVersion);
    if (optOut) {
        return version;
    }
    if (version == null) {
        throw new Error(`Failed to parse Pulumi CLI version. This is probably an internal error. You can override this by setting "${SKIP_VERSION_CHECK_VAR}" to "true".`);
    }
    if (minVersion.major < version.major) {
        throw new Error(`Major version mismatch. You are using Pulumi CLI version ${currentVersion.toString()} with Automation SDK v${minVersion.major}. Please update the SDK.`);
    }
    if (minVersion.compare(version) === 1) {
        throw new Error(`Minimum version requirement failed. The minimum CLI version requirement is ${minVersion.toString()}, your current CLI version is ${currentVersion.toString()}. Please update the Pulumi CLI.`);
    }
    return version;
}
exports.parseAndValidatePulumiVersion = parseAndValidatePulumiVersion;
//# sourceMappingURL=localWorkspace.js.map