"use strict";
// Copyright 2016-2021, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const index_1 = require("../../index");
const util_1 = require("../util");
const gstruct = require("google-protobuf/google/protobuf/struct_pb.js");
class TestComponentResource extends index_1.ComponentResource {
    constructor(name, opts) {
        super("test:index:component", name, {}, opts);
        super.registerOutputs({});
    }
}
class TestCustomResource extends index_1.CustomResource {
    constructor(name, type, opts) {
        super(type || "test:index:custom", name, {}, opts);
    }
}
class TestErrorResource extends index_1.CustomResource {
    constructor(name) {
        super("error", name, {});
    }
}
class TestResourceModule {
    construct(name, type, urn) {
        switch (type) {
            case "test:index:component":
                return new TestComponentResource(name, { urn });
            case "test:index:custom":
                return new TestCustomResource(name, type, { urn });
            default:
                throw new Error(`unknown resource type ${type}`);
        }
    }
}
class TestMocks {
    call(args) {
        throw new Error(`unknown function ${args.token}`);
    }
    newResource(args) {
        switch (args.type) {
            case "test:index:component":
                return { id: undefined, state: {} };
            case "test:index:custom":
            case "test2:index:custom":
                return {
                    id: index_1.runtime.isDryRun() ? undefined : "test-id",
                    state: {},
                };
            case "error":
                throw new Error("this is an intentional error");
            default:
                throw new Error(`unknown resource type ${args.type}`);
        }
    }
}
// eslint-disable-next-line @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match
const TestStrEnum = {
    Foo: "foo",
    Bar: "bar",
};
// eslint-disable-next-line @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match
const TestIntEnum = {
    One: 1,
    Zero: 0,
};
// eslint-disable-next-line @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match
const TestNumEnum = {
    One: 1.0,
    ZeroPointOne: 0.1,
};
// eslint-disable-next-line @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match
const TestBoolEnum = {
    One: true,
    Zero: false,
};
describe("runtime", () => {
    beforeEach(() => {
        index_1.runtime._reset();
        index_1.runtime._resetResourcePackages();
        index_1.runtime._resetResourceModules();
    });
    describe("transferProperties", () => {
        describe("output values", () => {
            function* generateTests() {
                const testValues = [
                    { value: undefined, expected: null },
                    { value: null, expected: null },
                    { value: 0, expected: 0 },
                    { value: 1, expected: 1 },
                    { value: "", expected: "" },
                    { value: "hi", expected: "hi" },
                    { value: {}, expected: {} },
                    { value: [], expected: [] },
                ];
                for (const tv of testValues) {
                    for (const deps of [[], ["fakeURN1", "fakeURN2"]]) {
                        for (const isKnown of [true, false]) {
                            for (const isSecret of [true, false]) {
                                const resources = deps.map(dep => new index_1.DependencyResource(dep));
                                yield {
                                    name: `Output(${JSON.stringify(deps)}, ${JSON.stringify(tv.value)}, ` +
                                        `isKnown=${isKnown}, isSecret=${isSecret})`,
                                    input: new index_1.Output(resources, Promise.resolve(tv.value), Promise.resolve(isKnown), Promise.resolve(isSecret), Promise.resolve([])),
                                    expected: Object.assign(Object.assign(Object.assign({ [index_1.runtime.specialSigKey]: index_1.runtime.specialOutputValueSig }, isKnown && { value: tv.expected }), isSecret && { secret: isSecret }), (deps.length > 0) && { dependencies: deps }),
                                    expectedRoundTrip: new index_1.Output(resources, Promise.resolve(isKnown ? tv.expected : undefined), Promise.resolve(isKnown), Promise.resolve(isSecret), Promise.resolve([])),
                                };
                            }
                        }
                    }
                }
            }
            function assertOutputsEqual(a, e) {
                return __awaiter(this, void 0, void 0, function* () {
                    function urns(res) {
                        return __awaiter(this, void 0, void 0, function* () {
                            const result = new Set();
                            for (const r of res) {
                                result.add(yield r.urn.promise());
                            }
                            return result;
                        });
                    }
                    assert.deepStrictEqual(yield urns(a.resources()), yield urns(e.resources()));
                    assert.deepStrictEqual(yield a.isKnown, yield e.isKnown);
                    assert.deepStrictEqual(yield a.promise(), yield e.promise());
                    assert.deepStrictEqual(yield a.isSecret, yield e.isSecret);
                    assert.deepStrictEqual(yield urns(yield a.allResources()), yield urns(yield e.allResources()));
                });
            }
            for (const test of generateTests()) {
                it(`marshals ${test.name} correctly`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
                    index_1.runtime._setTestModeEnabled(true);
                    index_1.runtime._setFeatureSupport("outputValues", true);
                    const inputs = { value: test.input };
                    const expected = { value: test.expected };
                    const actual = yield index_1.runtime.serializeProperties("test", inputs, { keepOutputValues: true });
                    assert.deepStrictEqual(actual, expected);
                    // Roundtrip.
                    const back = index_1.runtime.deserializeProperties(gstruct.Struct.fromJavaScript(actual));
                    yield assertOutputsEqual(back.value, test.expectedRoundTrip);
                })));
            }
        });
        it("marshals basic properties correctly", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            const inputs = {
                "aNum": 42,
                "bStr": "a string",
                "cUnd": undefined,
                "dArr": Promise.resolve(["x", 42, Promise.resolve(true), Promise.resolve(undefined)]),
                "id": "foo",
                "urn": "bar",
                "strEnum": TestStrEnum.Foo,
                "intEnum": TestIntEnum.One,
                "numEnum": TestNumEnum.One,
                "boolEnum": TestBoolEnum.One,
            };
            // Serialize and then deserialize all the properties, checking that they round-trip as expected.
            const transfer = gstruct.Struct.fromJavaScript(yield index_1.runtime.serializeProperties("test", inputs));
            const result = index_1.runtime.deserializeProperties(transfer);
            assert.strictEqual(result.aNum, 42);
            assert.strictEqual(result.bStr, "a string");
            assert.strictEqual(result.cUnd, undefined);
            assert.deepStrictEqual(result.dArr, ["x", 42, true, null]);
            assert.strictEqual(result.id, "foo");
            assert.strictEqual(result.urn, "bar");
            assert.strictEqual(result.strEnum, TestStrEnum.Foo);
            assert.strictEqual(result.intEnum, TestIntEnum.One);
            assert.strictEqual(result.numEnum, TestNumEnum.One);
            assert.strictEqual(result.boolEnum, TestBoolEnum.One);
        })));
        it("marshals secrets correctly", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            index_1.runtime._setTestModeEnabled(true);
            const inputs = {
                "secret1": index_1.secret(1),
                "secret2": index_1.secret(undefined),
            };
            // Serialize and then deserialize all the properties, checking that they round-trip as expected.
            index_1.runtime._setFeatureSupport("secrets", true);
            let transfer = gstruct.Struct.fromJavaScript(yield index_1.runtime.serializeProperties("test", inputs));
            let result = index_1.runtime.deserializeProperties(transfer);
            assert.ok(index_1.runtime.isRpcSecret(result.secret1));
            assert.ok(index_1.runtime.isRpcSecret(result.secret2));
            assert.strictEqual(index_1.runtime.unwrapRpcSecret(result.secret1), 1);
            assert.strictEqual(index_1.runtime.unwrapRpcSecret(result.secret2), null);
            // Serialize and then deserialize all the properties, checking that they round-trip as expected.
            index_1.runtime._setFeatureSupport("secrets", false);
            transfer = gstruct.Struct.fromJavaScript(yield index_1.runtime.serializeProperties("test", inputs));
            result = index_1.runtime.deserializeProperties(transfer);
            assert.ok(!index_1.runtime.isRpcSecret(result.secret1));
            assert.ok(!index_1.runtime.isRpcSecret(result.secret2));
            assert.strictEqual(result.secret1, 1);
            assert.strictEqual(result.secret2, undefined);
        })));
        it("marshals resource references correctly during preview", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            index_1.runtime._setIsDryRun(true);
            index_1.runtime.setMocks(new TestMocks());
            const component = new TestComponentResource("test");
            const custom = new TestCustomResource("test");
            const componentURN = yield component.urn.promise();
            const customURN = yield custom.urn.promise();
            const customID = yield custom.id.promise();
            const inputs = {
                "component": component,
                "custom": custom,
            };
            index_1.runtime._setFeatureSupport("resourceReferences", true);
            let serialized = yield index_1.runtime.serializeProperties("test", inputs);
            assert.deepEqual(serialized, {
                "component": {
                    [index_1.runtime.specialSigKey]: index_1.runtime.specialResourceSig,
                    "urn": componentURN,
                },
                "custom": {
                    [index_1.runtime.specialSigKey]: index_1.runtime.specialResourceSig,
                    "urn": customURN,
                    "id": customID,
                },
            });
            index_1.runtime._setFeatureSupport("resourceReferences", false);
            serialized = yield index_1.runtime.serializeProperties("test", inputs);
            assert.deepEqual(serialized, {
                "component": componentURN,
                "custom": customID ? customID : index_1.runtime.unknownValue,
            });
        })));
        it("marshals resource references correctly during update", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            index_1.runtime.setMocks(new TestMocks());
            const component = new TestComponentResource("test");
            const custom = new TestCustomResource("test");
            const componentURN = yield component.urn.promise();
            const customURN = yield custom.urn.promise();
            const customID = yield custom.id.promise();
            const inputs = {
                "component": component,
                "custom": custom,
            };
            index_1.runtime._setFeatureSupport("resourceReferences", true);
            let serialized = yield index_1.runtime.serializeProperties("test", inputs);
            assert.deepEqual(serialized, {
                "component": {
                    [index_1.runtime.specialSigKey]: index_1.runtime.specialResourceSig,
                    "urn": componentURN,
                },
                "custom": {
                    [index_1.runtime.specialSigKey]: index_1.runtime.specialResourceSig,
                    "urn": customURN,
                    "id": customID,
                },
            });
            index_1.runtime._setFeatureSupport("resourceReferences", false);
            serialized = yield index_1.runtime.serializeProperties("test", inputs);
            assert.deepEqual(serialized, {
                "component": componentURN,
                "custom": customID,
            });
        })));
    });
    describe("deserializeProperty", () => {
        it("fails on unsupported secret values", () => {
            assert.throws(() => index_1.runtime.deserializeProperty({
                [index_1.runtime.specialSigKey]: index_1.runtime.specialSecretSig,
            }));
        });
        it("fails on unknown signature keys", () => {
            assert.throws(() => index_1.runtime.deserializeProperty({
                [index_1.runtime.specialSigKey]: "foobar",
            }));
        });
        it("pushed secretness up correctly", () => {
            const secretValue = {
                [index_1.runtime.specialSigKey]: index_1.runtime.specialSecretSig,
                "value": "a secret value",
            };
            const props = gstruct.Struct.fromJavaScript({
                "regular": "a normal value",
                "list": ["a normal value", "another value", secretValue],
                "map": { "regular": "a normal value", "secret": secretValue },
                "mapWithList": {
                    "regular": "a normal value",
                    "list": ["a normal value", secretValue],
                },
                "listWithMap": [{
                        "regular": "a normal value",
                        "secret": secretValue,
                    }],
            });
            const result = index_1.runtime.deserializeProperties(props);
            // Regular had no secrets in it, so it is returned as is.
            assert.strictEqual(result.regular, "a normal value");
            // One of the elements in the list was a secret, so the secretness is promoted to top level.
            assert.strictEqual(result.list[index_1.runtime.specialSigKey], index_1.runtime.specialSecretSig);
            assert.strictEqual(result.list.value[0], "a normal value");
            assert.strictEqual(result.list.value[1], "another value");
            assert.strictEqual(result.list.value[2], "a secret value");
            // One of the values of the map was a secret, so the secretness is promoted to top level.
            assert.strictEqual(result.map[index_1.runtime.specialSigKey], index_1.runtime.specialSecretSig);
            assert.strictEqual(result.map.value.regular, "a normal value");
            assert.strictEqual(result.map.value.secret, "a secret value");
            // The nested map had a secret in one of the values, so the entire thing becomes a secret.
            assert.strictEqual(result.mapWithList[index_1.runtime.specialSigKey], index_1.runtime.specialSecretSig);
            assert.strictEqual(result.mapWithList.value.regular, "a normal value");
            assert.strictEqual(result.mapWithList.value.list[0], "a normal value");
            assert.strictEqual(result.mapWithList.value.list[1], "a secret value");
            // An array element contained a secret (via a nested map), so the entrie array becomes a secret.
            assert.strictEqual(result.listWithMap[index_1.runtime.specialSigKey], index_1.runtime.specialSecretSig);
            assert.strictEqual(result.listWithMap.value[0].regular, "a normal value");
            assert.strictEqual(result.listWithMap.value[0].secret, "a secret value");
        });
        it("deserializes resource references properly during preview", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            index_1.runtime.setMocks(new TestMocks());
            index_1.runtime._setFeatureSupport("resourceReferences", true);
            index_1.runtime.registerResourceModule("test", "index", new TestResourceModule());
            const component = new TestComponentResource("test");
            const custom = new TestCustomResource("test");
            const unregistered = new TestCustomResource("test", "test2:index:custom");
            const componentURN = yield component.urn.promise();
            const customURN = yield custom.urn.promise();
            const customID = yield custom.id.promise();
            const unregisteredURN = yield unregistered.urn.promise();
            const unregisteredID = yield unregistered.id.promise();
            const outputs = {
                "component": {
                    [index_1.runtime.specialSigKey]: index_1.runtime.specialResourceSig,
                    "urn": componentURN,
                },
                "custom": {
                    [index_1.runtime.specialSigKey]: index_1.runtime.specialResourceSig,
                    "urn": customURN,
                    "id": customID,
                },
                "unregistered": {
                    [index_1.runtime.specialSigKey]: index_1.runtime.specialResourceSig,
                    "urn": unregisteredURN,
                    "id": unregisteredID,
                },
            };
            const deserialized = index_1.runtime.deserializeProperty(outputs);
            assert.ok(deserialized["component"].__pulumiComponentResource);
            assert.ok(deserialized["custom"].__pulumiCustomResource);
            assert.deepEqual(deserialized["unregistered"], unregisteredID);
        })));
    });
    describe("resource error handling", () => {
        it("registerResource errors propagate appropriately", util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
            index_1.runtime.setMocks(new TestMocks());
            yield assert.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
                const errResource = new TestErrorResource("test");
                const customURN = yield errResource.urn.promise();
                const customID = yield errResource.id.promise();
            }), (err) => {
                const containsMessage = err.stack.indexOf("this is an intentional error") >= 0;
                const containsRegisterResource = err.stack.indexOf("registerResource") >= 0;
                return containsMessage && containsRegisterResource;
            });
        })));
    });
});
//# sourceMappingURL=props.spec.js.map